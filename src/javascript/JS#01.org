#+TITLE: Introducci√≥n a JavaScript
#+DESCRIPTION: Introducci√≥n a JavaScript.
#+AUTHOR: Sergio Ben√≠tez
#+DATE:<2018-05-13 Sun>
#+STARTUP: fold
#+HUGO_BASE_DIR: ~/Development/suabochica-blog/
#+HUGO_SECTION: /post
#+HUGO_WEIGHT: auto
#+HUGO_AUTO_SET_LASTMOD: t

** ¬øQu√© es JavaScript?

JavaScript es un lenguaje de programaci√≥n de computadoras /ligero/, /multiplataforma/ y /multiparadigma/.

- **Ligero** significa que es un lenguaje que no utiliza mucha memoria de la computadora y est√° compuesto por una sintaxis y caracter√≠sticas sencillas.
- **Multiplataforma** significa que puede ser utilizado en m√∫ltiples plataformas y sistemas.
- **Multiparadigma** significa que es un lenguaje que puede usar progamaci√≥n basada en objetos y programaci√≥n funcional.

JavaScript es una de las tres tecnolog√≠as fundamentales del desarrollo web (HTML y CSS son las otras 2). Hoy en d√≠a, JavaScript puede usarse en diferentes entornos:

- **Del lado del cliente**: JavaScript se usaba tradicionalmente solo en el navegador.
- **Del lado del servidor**: Gracias a Node.js, podemos usar JavaScript tambi√©n en el servidor.

JavaScript es lo que ha hecho posible el desarrollo web moderno a trav√©s de efectos din√°micos e interactividad. Es importante mencionar que hoy en d√≠a existen muchas bibliotecas y frameworks de JavaScript que implementan diferentes arquitecturas y ayudan a los desarrolladores a construir aplicaciones complejas de manera m√°s eficiente y r√°pida que nunca. Todas estas bibliotecas y frameworks est√°n basados en JavaScript, por lo que, antes de utilizarlos, los desarrolladores deben ser buenos en JavaScript y entenderlo bien.

#+begin_quote
Una /biblioteca/ es simplemente un archivo con funciones/m√©todos u otro c√≥digo reutilizable que puedes enlazar y usar en tu propio c√≥digo. Por otro lado un /marco de trabajo/ (framework) es un t√©rmino amplio. Wikipedia dice que un framework es un entorno de software universal y reutilizable que proporciona funcionalidad particular. Los frameworks de software pueden incluir programas de soporte, compiladores, bibliotecas de c√≥digo, conjuntos de herramientas e interfaces de programaci√≥n de aplicaciones (APIs) que re√∫nen todos los diferentes componentes para permitir el desarrollo de un proyecto o sistema.
#+end_quote

JavaScript puede crearse en 2 formas:

1. **Script en l√≠nea**: Poniendo el c√≥digo JavaScript dentro de la etiqueta ~<script>~.
2. **Script externo**: Escribir el c√≥digo JavaScript en un archivo externo e importarlo usando el atributo ~src~ de la etiqueta ~<script>~.

** Variables y Tipos de Datos

Una variable es un contenedor en el que podemos almacenar un valor para usarlo posteriormente. Al guardar un valor en una variable, no es necesario escribirlo cada vez que queramos usarlo.

El tipo de dato de un valor es un atributo que nos dice qu√© tipo de dato puede contener ese valor. En otras palabras, es una clasificaci√≥n de datos que le indica al compilador o int√©rprete c√≥mo el programador pretende usar los datos. En JavaScript tenemos los siguientes tipos de datos primitivos:

- **Number**: N√∫meros de punto flotante, para decimales y enteros.
- **String**: Secuencia de caracteres, usada para texto.
- **Boolean**: Un tipo de dato l√≥gico que solo puede ser true (verdadero) o false (falso).
- **Undefined**: Tipo de dato de una variable que a√∫n no tiene valor.
- **Null**: Tambi√©n significa no existente.

JavaScript tiene una caracter√≠stica llamada tipado din√°mico. Esto significa que el programador no tiene que definir manualmente el tipo de dato de la variable. JavaScript determina el tipo de dato por s√≠ mismo, lo que significa que incluso podemos cambiar el tipo de una variable m√°s adelante en nuestro c√≥digo. Esto puede ser muy √∫til, pero tambi√©n puede ser la fuente de errores dif√≠ciles de encontrar. Existe una envoltura para evitar el tipado din√°mico en JavaScript llamada TypeScript.

** Mutaci√≥n de Variables y Coerci√≥n de Tipos

La **coerci√≥n de tipos** es una caracter√≠stica de JavaScript relacionada con el tipado din√°mico. B√°sicamente significa que, cuando tienes diferentes tipos de datos y los mezclas, JavaScript intenta autom√°ticamente averiguar qu√© variable debe convertir y luego las convierte todas al mismo tipo. Veamos algunos ejemplos:

#+BEGIN_SRC javascript
var name = 'Edward';
var age = 20;

console.log(nombre + edad); //-> 'Edward20' (Aplica coerci√≥n de tipos sobre la edad, convirti√©ndola en una cadena de texto)
console.log(edad + edad); //-> 40
#+END_SRC

La mutaci√≥n de variables es, como su nombre indica, cambiar el valor de una variable. Consideremos el siguiente ejemplo como una continuaci√≥n del c√≥digo anterior:

#+BEGIN_SRC javascript
age = 'twenty;
console.log(age); //-> 'Twenty'
#+END_SRC

En este c√≥digo, cambias el valor de la variable edad de 20 a "veinte". Observa que no usaste la palabra clave var porque solo se usa para declarar variables la primera vez. Es importante saber que el compilador de JavaScript lee nuestro c√≥digo en una secuencia de instrucciones de arriba hacia abajo.

** Operadores B√°sicos

Los **operadores** son construcciones que se comportan generalmente como funciones, pero que difieren sint√°ctica o sem√°nticamente de las funciones usuales. Los tipos m√°s comunes de operadores simples son:

- Operadores aritm√©ticos.
- Operadores de comparaci√≥n.
- Operadores de asignaci√≥n.
- Operadores l√≥gicos.

Un aspecto esencial de los operadores es el orden en el que el lenguaje de programaci√≥n ejecuta estas operaciones. En JavaScript, existen precedencias de operadores para definir cu√°les se ejecutan primero y cu√°les se completan despu√©s. Las matem√°ticas establecen la precedencia, pero JavaScript cuenta con varios operadores, y toda la precedencia de ellos se define en una tabla de referencia. Con este contexto, podemos identificar los valores de la siguiente operaci√≥n:

#+BEGIN_SRC javascript
var randomOperationsValue = 3 + 5 * 5 - 2;
console.log(randomOperationsValue); //-> 26
#+END_SRC

*** Precedencia de Operadores

Como mencion√© antes, la precedencia de operadores define qu√© operador se ejecuta primero. Para ilustrar el concepto, analicemos el siguiente c√≥digo donde, dado un ~birthYear~ (a√±o de nacimiento), determinaremos si una persona es mayor de edad.

#+BEGIN_SRC javascript
var no = 2018;
var birthYearEdward = 1991;
var fullAge = 18;

var isFullAge = now - birthYearEdward >= fullAge; //-> True
#+END_SRC

Nuestra atenci√≥n est√° en la √∫ltima l√≠nea de c√≥digo. All√≠ estamos usando tres operadores: >=, - y =. Para validar la precedencia de cada operador, podemos consultar la Tabla de Precedencia de Operadores de JavaScript. En esa tabla, tenemos:

| Precedencia | Tipo de operador       | Asociatividad       | Operadores individuales |
|-------------|------------------------|---------------------|-------------------------|
| 3           | Asignaci√≥n             | derecha a izquierda | ~...=...~               |
| 11          | Mayor o igual que (>=) | izquierda a derecha | ~...>=...~              |
| 13          | Resta (-)              | izquierda a derecha | ~...-...~               |

Entonces, ¬øc√≥mo sabe JavaScript cu√°l operador ejecutar primero? Imagina que primero se ejecuta ~birthYearEdward >= fullAge~. Esto devolver√≠a un valor true o false. Luego ~now - true~, pero esto no tendr√≠a sentido y, por supuesto, no ser√≠a lo que queremos.

En cambio, queremos que primero se ejecute ~now - birthYearEdward~, y luego comparar esa edad con el valor de ~fullAge~. Esta es la ejecuci√≥n que sigue JavaScript porque, como puedes ver, el operador ~-~ tiene una mayor precedencia que el operador ~>=~. Finalmente, se ejecuta el ~=~ porque este operador tiene una precedencia m√°s baja que los dem√°s.

Veamos un ejemplo de asignaci√≥n m√∫ltiple para comprender qu√© significa la columna de asociatividad de la tabla:

#+BEGIN_SRC javascript
// Multiple Assignment
var x, y

x = y = (3 + 5) * 4 - 6 // 26

// More operators
x *= 2 // 54
x += 10 // 64
x++ // 65
x-- // 64
#+END_SRC

En la tabla de precedencia podemos observar lo siguiente:

| Precedencia | Tipo de operador | Asociatividad       | Operadores individuales |
|-------------|------------------|---------------------|-------------------------|
| 13          | Suma             | izquierda a derecha | ~+~                     |
| 14          | Multiplicaci√≥n   | izquierda a derecha | ~*~                     |
| 20          | Agrupamiento     | n/a                 | ~( ... )~               |

Entonces, ¬øc√≥mo ejecutar√° JavaScript ~x = y = (3 + 5) * 4 - 6~? Primero, comenzar√° con ~(3 + 5)~ porque el operador de agrupamiento ~( ... )~ tiene la mayor precedencia. Luego obtenemos ~8~. Segundo, JavaScript ejecutar√° ~8 * 4~, porque el operador ~*~ tiene mayor precedencia que ~-~ . Luego obtenemos ~32~. Tercero, ejecutar√° ~32 - 6~ para obtener ~26~.

** Estructuras de Control

JavaScript, como la mayor√≠a de los lenguajes de programaci√≥n, tiene un par de estructuras de control.

#+BEGIN_QUOTE
**Estructuras de Control**: Las estructuras de control permiten ejecutar solo ciertas partes de nuestro c√≥digo ‚Äìlas sentencias ~if/else~ ‚Äì o ejecutar algunas partes m√∫ltiples veces ‚Äìlos bucles‚Äì.
#+END_QUOTE

Las sentencias **if/else** nos permiten tomar decisiones con nuestro c√≥digo dependiendo de una condici√≥n. Para evitar malentendidos en JavaScript al momento de definir una condici√≥n, debes comprender la diferencia entre los operadores ~==~ y ~===~. La principal diferencia es que ~==~ permite la coerci√≥n de tipos y ~===~ no. Es una buena pr√°ctica usar ~===~ para tener control sobre la coerci√≥n de tipos en JavaScript.

*** L√≥gica Booleana

La l√≥gica booleana es una rama de la inform√°tica que se encarga de los valores verdaderos y falsos. Para lograr esto, debes usar varios operadores l√≥gicos (AND ~&&~, OR ~||~ y NOT ~!~). Aprender esto te ayudar√° a dominar las sentencias ~if/else~ en los lenguajes de programaci√≥n. A continuaci√≥n, puedes ver las respectivas tablas de verdad de los operadores l√≥gicos AND y OR. Las tablas de verdad nos permiten ver el resultado de los operadores al momento de evaluar las variables.

|*AND*  |True    |False  |
|-------|--------|-------|
|True   |True    |False  |
|False  |False   |False  |

AND ~&&~ => Verdadero si todos son verdaderos.

|*OR*   |True   |False  |
|-------|-------|-------|
|True   |True   |True   |
|False  |True   |False  |

OR ~||~ => Verdadero si uno es verdadero.
NOT ~!~ => Invierte el valor verdadero/falso.

De acuerdo con la siguiente explicaci√≥n, tenemos los siguientes ejemplos:

#+BEGIN_SRC javascript
var age = 16;

age >= 20;      //-> Falso
age < 30;       //-> Verdadero
!(age < 30)     //-> Falso

age >= 20 && age < 30; //-> Falso
age >= 20 || age < 30; //-> Verdadero
#+END_SRC

*** Sentencia ~switch~

La sentencia ~switch~ es otra forma de tomar decisiones en JavaScript. Es adecuada cuando tienes muchos casos diferentes para una variable, evitando el abuso de las sentencias ~if/else if/else~. A continuaci√≥n, un ejemplo de una sentencia switch:

#+BEGIN_SRC javascript
var job = 'teacher';

switch:
    case 'teacher':
        console.log('Hohenheim teaches kids.');
        break;
    case 'driver':
        console.log('Hohenheim drives a car in Amestris.');
        break;
    case 'cop':
        console.log('Hohenheim fights crime.');
        break;
    default:
        console.log('Hohenheim does something else.');
        break;
#+END_SRC

JavaScript ahora revisar√° cada uno de estos casos uno por uno y decidir√° cu√°l es el correcto. La palabra clave ~break~ es necesaria en caso de que JavaScript decida que este es el caso correcto, entonces despu√©s de esto, necesita salir de la sentencia switch sin revisar los otros casos diferentes.

*** Valores ~Falsy~ y ~Truthy~

En JavaScript, un valor **Falsy** es un valor que se considera ~false~ cuando se eval√∫a en una condici√≥n ~if/else~. Estos valores son: ~undefined~, ~null~, ~0~, ~''~ (cadena vac√≠a) y ~NaN~. Para ilustrar este concepto, revisemos el siguiente ejemplo:

#+BEGIN_SRC javascript
var height;

if (height) {
    console.log('Variable is defined')
} else {
    console.log('Variable has NOT been defined') // Printed value
}
#+END_SRC

En el c√≥digo anterior, declaramos la variable ~height~ pero nunca la definimos. Entonces, cuando JavaScript eval√∫a el valor en la sentencia ~if/else~, obtenemos ~undefined~ y lo convierte en falso. Es por eso que los llamamos ~Falsy~, porque no son exactamente falsos, pero resultar√°n ser falsos cuando se eval√∫en en una condici√≥n ~if/else~.

Adem√°s, tenemos valores ~Truthy~, que son aquellos que se consideran verdaderos cuando se eval√∫an en una condici√≥n ~if/else~. B√°sicamente, son todos los valores que no son ~Falsy~. Para ilustrarlo, arreglemos el √∫ltimo ejemplo:

#+BEGIN_SRC javascript
var height = 20;

if (height) {
    console.log('Variable is defined') // Printed value
} else {
    console.log('Variable has NOT been defined')
}
#+END_SRC

Aqu√≠, ~height~ est√° definida y luego se eval√∫a como verdadero en la sentencia ~if/else~.

** Funciones

Imagina que tienes un fragmento de c√≥digo que deseas ejecutar muchas veces. Adem√°s, quieres usarlo una y otra vez en tu c√≥digo. En lugar de escribirlo repetidamente, puedes poner este fragmento de c√≥digo dentro de una /funci√≥n/.

Las funciones son contenedores que almacenan un par de l√≠neas de c√≥digo. En estos contenedores, puedes pasar argumentos, ya que la funci√≥n puede recibir informaci√≥n desde fuera y, finalmente, la funci√≥n puede devolver un resultado. Puedes pensar en las funciones como una m√°quina que recibe algunos insumos, hace algo con ellos y genera un resultado. Las funciones son una herramienta vital para combatir el principio de programaci√≥n **DRY (Don‚Äôt Repeat Yourself o "No te repitas")**. Para evitar la repetici√≥n de c√≥digo, solemos usar funciones. En el siguiente ejemplo usamos funciones para calcular la edad y el tiempo de jubilaci√≥n:

#+BEGIN_SRC javascript
function calculateAge(yearOfBirth) {
    var age = 2018 - yearOfBirth;

    return age;
}

var ageEdward = calculateAge(2000); //-> 18
var ageAlphonse = calculateAge(2002); //->16
var ageHohenheim = calculateAge(1900); //-> 118


function yearsUntilRetirement(name, year) {
    var age = calculateAge(year),
        retirement = 65 - age;
    if(retirement > 0) {
        console.log(name + ' retires in ' + retirement + ' years');
    } else {
        console.log(name + ' is already retired');
    }
}

yearsUntilRetirement('Edward', 2000); //-> 'Edward retires in 47 years'
yearsUntilRetirement('Alphonse', 2002); //-> 'Alphonse retires in 49 years'
yearsUntilRetirement('Hohenheim', 1900); //-> 'Hohenheim is already retired'
#+END_SRC

*** Instrucciones y Expresiones

Antes de continuar, es una buena idea entender que en JavaScript las funciones pueden ser definidas en t√©rminos de **expresiones** o **instrucciones**. La diferencia entre una instrucci√≥n y una expresi√≥n es que una expresi√≥n /produce un valor/, un resultado inmediato, mientras que una instrucci√≥n simplemente /realiza una acci√≥n/. A continuaci√≥n, puedes ver ejemplos de cada una:

#+BEGIN_SRC javascript
// Expressions
var x = 3;
3 + 2

// Statements
if (x === 5) {
    //Do something ...
}
#+END_SRC

En JavaScript puedes identificar si una funci√≥n es una expres√≥n o una instrucci√≥n de acuerdo a la sint√°xis usada:

#+BEGIN_SRC javascript
function fnStatement() {
    // code
}

var fnExpression = function() {
    // code
}
#+END_SRC

** Arreglos

En las notas anteriores, dentro de los ejemplos, utilizamos diferentes variables para diferentes personas. Estas variables podr√≠an agruparse en una sola variable. JavaScript tiene diferentes formas de agrupar datos y una de ellas son los **arreglos**. El siguiente c√≥digo muestra un arreglo de nombres y un arreglo de a√±os:

#+BEGIN_SRC javascript
var names = ['Edward', 'Alphonse', 'Hohenheim'];
var years = new Array(2000, 2002, 1900);

console.log(names) //-> ['Edward', 'Alphonse', 'Hohenheim']
console.log(names[1]) //-> Alphonse
#+END_SRC

Como puedes ver, existen dos formas de definir un arreglo. La m√°s com√∫nmente utilizada es la primera. Un arreglo puede contener tantos tipos de datos diferentes como queramos. Para acceder a un elemento de un arreglo, debes usar el ~√≠ndice~. En JavaScript, los arreglos son indexados desde cero, por lo que el primer elemento del arreglo tiene el √≠ndice ~0~. Adem√°s, JavaScript ofrece un conjunto de funciones para agregar/eliminar elementos en un arreglo, cambiando el arreglo original:

- ~.push(elemento)~: Agrega un elemento en la √∫ltima posici√≥n del arreglo.
- ~.unshift(elemento)~: Agrega un elemento en la primera posici√≥n del arreglo.
- ~.pop()~: Elimina un elemento en la √∫ltima posici√≥n del arreglo.
- ~.shift()~: Elimina un elemento en la primera posici√≥n del arreglo.
- ~.indexOf(elemento)~: Devuelve el √≠ndice del elemento pasado como par√°metro.

** Objetos

Los objetos son probablemente el tema m√°s importante en JavaScript. Al igual que los arreglos, los objetos nos permiten almacenar varias variables en una sola variable. /Una diferencia entre los objetos y los arreglos es la forma de acceder a los elementos/. En un arreglo, utilizas un n√∫mero de orden y en un objeto, utilizas un nombre espec√≠fico ‚Äîuna clave‚Äî. En los objetos, tienes pares clave/valor, lo que significa que cada valor tiene una clave. Usas objetos para agrupar diferentes variables que no tienen un orden particular. En el siguiente ejemplo, utilizaremos un objeto para definir los datos asociados a una persona:

#+BEGIN_SRC javascript
var edward = {
    name: 'Edward',
    lastName: 'Elric',
    yearOfBirth: 2000,
    job: 'Alchemist',
    isMarried: true
};


console.log(edward) //-> Prints the edward object
console.log(edward.job) //-> 'Alchemist'. To access the edward object you can use the dot notation
console.log(edward['yearOfBirth']) //-> 2000. To access the edward object you can also use the brackets notation

var alphonse =  new Object();

alphonse.name = 'Alphonse';
alphonse.lastName = 'Elric';
alphonse.yearOfBirth = 2002;
alphonse.job = 'Alchemist';
alphonse.isMarried = false;
#+END_SRC

Como puedes ver, existen dos maneras de definir un objeto. La m√°s com√∫nmente utilizada es la primera. Adem√°s, tenemos dos formas de acceder a las propiedades de un objeto: /la notaci√≥n de punto/ y /la notaci√≥n de corchetes/. La mutaci√≥n de objetos se realiza a trav√©s del acceso a las propiedades, de manera similar a la mutaci√≥n de arreglos.

#+BEGIN_QUOTE
¬øCu√°l es la diferencia entre una Clase y un Objeto?

Un Objeto es una colecci√≥n de datos relacionados. Un objeto puede tener propiedades (variables que pertenecen al objeto) y m√©todos (funciones que pertenecen al objeto). Podemos acceder a ellos utilizando notaci√≥n de punto o notaci√≥n de corchetes. Una Clase funciona como un constructor de funciones y adem√°s puedes definir m√©todos dentro de una clase, los cuales ser√°n heredados por las instancias de esta clase.
#+END_QUOTE

*** M√©todos de objetos

Los **m√©todos de objetos** son una caracter√≠stica espec√≠fica de los objetos en JavaScript. Como puedes ver, un objeto puede contener diferentes tipos de datos, como un entero, una cadena, un booleano e inclusive un arreglo. Pero eso no es todo lo que un objeto puede contener; los objetos tambi√©n pueden tener otros objetos o funciones. A continuaci√≥n, puedes ver un ejemplo de c√≥digo de un objeto que contiene un array y una expresi√≥n de funci√≥n:

#+BEGIN_SRC javascript
var edward = {
    name: 'Edward',
    lastName: 'Elric',
    yearOfBirth: 2000,
    job: 'Alchemist',
    isMarried: true
    family: ['Trisha', 'Hohenheim', 'Alphonse'],
    calculateAge: function(yearOfBirth) {
        return 2018 - yearOfBirth;
    }
};

console.log(edward); //-> Prints the edward object
console.log(edward.family); //-> ['Trisha', 'Hohenheim', 'Alphonse']
console.log(edward.family[2]); //-> 'Alphonse'
console.log(edward.calculateAge(2000)); //-> 18
#+END_SRC

La clave ~calculateAge~ dentro del objeto ~edward~ es solo una variable, y luego se le asigna una funci√≥n. Para acceder a la funci√≥n ~calculateAge~, puedes usar la notaci√≥n de punto. Por lo tanto, los objetos pueden contener funciones, y estas funciones se llaman m√©todos. Con este contexto, puedes decir que las funciones ~push(element)~ y ~pop()~ son m√©todos del objeto Array. Ahora, puedes mejorar la expresi√≥n de la funci√≥n ~calculateAge()~ porque podr√≠as usar la propiedad ~yearOfBirth~ dentro del objeto ~edward~ para calcular la edad. Para lograr esto, podemos usar la palabra clave ~this~:

#+BEGIN_SRC javascript
var edward = {
    name: 'Edward',
    lastName: 'Elric',
    yearOfBirth: 2000,
    job: 'Alchemist',
    isMarried: true
    family: ['Trisha', 'Hohenheim', 'Alphonse'],
    calculateAge: function() {
        this.age = 2018 - this.yearOfBirth;
    }
};
edward.calculateAge();
console.log(edward); //-> Prints the edward object with the age property
#+END_SRC

El ~this~ en este ejemplo se referir√° al objeto ~edward~. Entonces, ~edward~ es el objeto que tiene el m√©todo ~calculateAge()~ y la propiedad ~yearOfBirth~, y la palabra clave ~this~ puede recuperar estos valores directamente de su propio objeto. Por otro lado, puedes almacenar autom√°ticamente el resultado de ~calculateAge()~ dentro del objeto ~edward~. La propiedad ~this.age~ nos permite lograr eso. En el m√©todo ~calculateAge()~, est√°s creando una nueva propiedad, calculando la edad y asignando la edad calculada a esta propiedad. La ventaja de esta estructura y del uso de ~this~ es la flexibilidad, porque si creas otro objeto con un ~yearOfBirth~ diferente, la edad se calcular√° con este valor, excluyendo el contexto del objeto ~edward~.

El this en este ejemplo se referir√° al objeto edward. Entonces, edward es el objeto que tiene el m√©todo calculateAge() y la propiedad yearOfBirth, y la palabra clave this puede recuperar estos valores directamente de su propio objeto. Por otro lado, puedes almacenar autom√°ticamente el resultado de calculateAge() dentro del objeto edward. La propiedad this.age nos permite lograr eso. En el m√©todo calculateAge(), est√°s creando una nueva propiedad, calculando la edad y asignando la edad calculada a esta propiedad. La ventaja de esta estructura y del uso de this es la flexibilidad, porque si creas otro objeto con un yearOfBirth diferente, la edad se calcular√° con este valor, excluyendo el contexto del objeto ~edward~.

El this en este ejemplo se referir√° al objeto edward. Entonces, edward es el objeto que tiene el m√©todo calculateAge() y la propiedad yearOfBirth, y la palabra clave this puede recuperar estos valores directamente de su propio objeto. Por otro lado, puedes almacenar autom√°ticamente el resultado de calculateAge() dentro del objeto edward. La propiedad this.age nos permite lograr eso. En el m√©todo calculateAge(), est√°s creando una nueva propiedad, calculando la edad y asignando la edad calculada a esta propiedad. La ventaja de esta estructura y del uso de this es la flexibilidad, porque si creas otro objeto con un yearOfBirth diferente, la edad se calcular√° con este valor, excluyendo el contexto del objeto ~edward~.

** Bucles

Los bucles son otra familia de estructuras de control en JavaScript. Los bucles son un aspecto muy importante de cualquier lenguaje de programaci√≥n, ya que ayudan al programador a manejar tareas repetitivas. En lugar de escribir diez l√≠neas de c√≥digo para ejecutar la misma tarea, solo tienes que seguir la estructura del bucle para lograr el mismo resultado con pocas l√≠neas de c√≥digo. La estructura de un bucle se compone de: un contador, una condici√≥n y una acci√≥n para actualizar el contador. JavaScript tiene dos tipos populares de bucles: ~while~ y ~for~.

*** Bucle While

A continuaci√≥n, se muestra la estructura de un bucle ~while~ para una tarea que imprime los n√∫meros del 0 al 9:

#+BEGIN_SRC javascript
var i = 0; // El contador

while (i < 10) { // La condici√≥n
    console.log(i);
    i++; // Acci√≥n para actualizar el contador
}

#+END_SRC

*** Bucle For

A continuaci√≥n, se muestra la estructura de un bucle ~for~ para lograr la misma tarea:

#+BEGIN_SRC javascript
for (var i = 0; i < 10; i++) { // Todos los elementos de un bucle est√°n en esta l√≠nea
    console.log(i);
}
#+END_SRC

Los bucles son una buena estructura de control para interactuar con arreglos:

#+BEGIN_SRC javascript
names = ['Edward', 'Alphonse', 'Trisha', 'Hohenheim'];

for (var i = 0; i < names.length; i++) { // .length es un m√©todo del objeto arreglo que devuelve la longitud del arreglo
    console.log(names[i]);
}

// Para recorrer el arreglo desde el √∫ltimo hasta el primer elemento
for (var i = names.length - 1; i >= 0; i--) {
    console.log(names[i]);
}
#+END_SRC

Adem√°s, el bucle ~for~ tiene mecanismos para romper o continuar el flujo del bucle bajo una condici√≥n. El siguiente ejemplo imprime los n√∫meros del 1 al 5, excepto el 3:

#+BEGIN_SRC javascript
for (var i = 0; i < 5; i++) {
    console.log(i);

    if (i === 3)
        break;
}

for (var i = 0; i < 5; i++) {
    if (i === 3)
        continue;

    console.log(i);
}
#+END_SRC

** ü™¨ Nota Importante: ES5, ES6/ES2015 y ES2016

Es importante hablar sobre la versi√≥n de JavaScript porque cada desarrollador moderno deber√≠a saber cu√°l es el contexto en la comunidad de JavaScript y c√≥mo el lenguaje de programaci√≥n se est√° adaptando a los cambios en varios temas hoy en d√≠a. La siguiente lista es una historia muy corta de JavaScript:

- **1996**: Cambio de LiveScript a JavaScript para atraer a los desarrolladores de Java ‚Äîuna acci√≥n de marketing‚Äî. Sin embargo, Java no tiene casi nada que ver con Java.
- **1997**: ECMAScript 1 se convirti√≥ en la primera versi√≥n del est√°ndar del lenguaje JavaScript. Esto significa que ECMA Script es el est√°ndar del lenguaje y JavaScript es el lenguaje en pr√°ctica. ECMA es una organizaci√≥n internacional.
- **2009**: ECMAScript 5 (ES5) fue lanzado con muchas caracter√≠sticas nuevas. Sin embargo, tom√≥ muchos a√±os para que los navegadores implementaran todos estos cambios, y hasta hace pocos a√±os los desarrolladores pudieron usar ES5 sin restricciones.
- **2015**: ECMAScript 2015 (ES2015) fue lanzado como la actualizaci√≥n m√°s grande de la historia con muchas nuevas caracter√≠sticas. Estas actualizaciones de versi√≥n son un gran asunto para JavaScript y toda la comunidad. Se escuchar√° que esta versi√≥n tambi√©n se llama ES6, pero es mejor usar ES2015 porque la organizaci√≥n ECMA lanzar√° cada a√±o nuevas versiones con algunas actualizaciones menores.

Entonces, ¬øc√≥mo est√° JavaScript hoy y qu√© versi√≥n deber√≠amos usar?

- **ES5** es completamente compatible con todos los navegadores modernos y est√° listo para usar desde 2016.
- **ES2015** tiene solo soporte parcial en navegadores modernos, sin soporte en navegadores antiguos. Por lo tanto, no se recomienda usarlo en producci√≥n.
- **ES2016** tiene casi ning√∫n soporte en navegadores modernos, por lo que, por esta raz√≥n, no se recomienda usarlo en producci√≥n. Sin embargo, la magnitud de esta versi√≥n es poco importante porque solo agrega una o dos peque√±as caracter√≠sticas al lenguaje.

En conclusi√≥n, /se recomienda usar ES5/. Adem√°s, es importante aprender a codificar en ES5 y entenderlo porque casi todos los tutoriales y c√≥digos que encuentres en la web hoy en d√≠a a√∫n est√°n en ES5, y es m√°s f√°cil aprender ES5 y luego actualizarse a ES2015.
