
#+TITLE: Conceptos fundamentales de React
#+DESCRIPTION: Serie que recopila una descripción general de React
#+AUTHOR: Sergio Benítez
#+DATE:<2021-03-18 Thu> 
#+STARTUP: fold
#+HUGO_BASE_DIR: ~/Development/suabochica-blog/
#+HUGO_SECTION: /post
#+HUGO_WEIGHT: auto
#+HUGO_AUTO_SET_LASTMOD: t

En esta publicación se van a revisar los conceptos fundamentales de React a través de la creación de una aplicación para adoptar mascotas

## JSX
Hasta ahora se ha estado escribiendo React sin JSX, no obstante todos los desarrolladores React usan JSX. JSX simplemente hace que su código sea un poco más legible.

Si se escribe ~React.createElement("h1", {id: "main-title"}, "MyWebsite");~ lo que se renderiza es ~<h1 id="main-title">MyWebsite</h1>~ . JSX acota esta capa de traducción, para ganar mayor legibilidad. En ese orden de ideas el componente ~Pet~ que se muestra a continuación:

#+begin_src js
const Pet = (props) => {
  return React.createElement(
    "div",
    {},
    [
      React.createElement("h2", {}, props.name),
      React.createElement("h3", {}, props.animal),
      React.createElement("h3", {}, props.breed),
    ]
  );
};
#+end_src

Puede escribirse con la sintáxis JSX de la siguiente manera:

#+begin_src js
const Pet = (props) => {
  return (
    <div>
        <h2>{props.name}</h2>
        <h3>{props.animal}</h3>
        <h3>{props.breed}</h3>
    </div>
  );
};

export default Pet;
#+end_src

Honestamente, esta segunda versión resulta más legible. Sin embargo, ahora sabe lo que JSX está haciendo por usted. Simplemente está traduciendo esas etiquetas HTML en llamadas ~React.createElement~. Eso es todo.

Siguiendo con esta línea, es tiempo de escribir el archivo ~App.jsx~ con JSX:

#+begin_src js
import { render } from "react-dom"
import Pet from "./Pet"

const App = () => {
  return (
    <div>
        <h1>Adopt Me!</h1>
        <Pet name="Luna" animal="dog" breed="Havanese"/>
        <Pet name="Pepper" animal="bird" breed="Cockatiel"/>
        <Pet name="Doink" animal="cat" breed="Mix"/>
    </div>
  );
};

export default Pet;
#+end_src

## ESLint + React

Es necesario darle una mano a ESLint para que reconozca React. Para ello es necesario correr el siguiente comando:

#+begin_src zsh
npm install -D eslint-plugin-import@2.22.1 eslint-plugin-jsx-a11y@6.4.1 eslint-plugin-react@7.22.0
#+end_src

Una vez instalado los plugins se debe actualizar el ~.eslintrc.json~ con el siguiente contenido:

#+begin_src json
{
  "extends": [
    "eslint:recommended",
    "plugin:import/errors",
    "plugin:react/recommended",
    "plugin:jsx-a11y/recommended",
    "prettier',
    "prettier/react'
  ],
  "rules": {
    "react/prop-types": 0,
    "react/react-in-jsx-scope": 0
  },
  "plugins": [
    "react",
    "import",
    "jsx-a11y"
  ],
  "parserOptions": {
    "ecmaVersion": 2021,
    "sourceType": "module",
    "ecmaFeatures": {
      "jsx": true
    }
  },
  "env": {
    "es6": true,
    "browser": true,
    "node": true
  },
  "settings": {
    "react": {
      "version": "detect"
    }
  }
}
#+end_src

Esta configuración es recomendada para trabajar proyecto personales. No obstante, es posible ahorrarse este pasa y simplemente usar le configuración [estándar](https://standardjs.com/), o la establecida por [airbnb](https://github.com/airbnb/javascript/tree/master/packages/eslint-config-airbnb). Esta configuración atiende los siguientes escenarios:

- El complemento ~react~ es sobre todo errores comunes de React, como no llamar a uno de los props en los componentes hijos.
- El complemento de ~import~ ayuda a ESLint a detectar errores comunes relacionados con importaciones, exportaciones y módulos en general.
- ~jsx-a11y~ detecta muchos errores relacionados con la accesibilidad que pueden surgir accidentalmente al usar React, como no tener un atributo ~alt~ en una etiqueta ~img~.
- ~eslint-plugin-react~ ahora requiere que le informe qué versión de React está usando. La instrucción es que detecte la version a través del ~package.json~.
- Las reglas ~react / react-in-jsx-scope: 0~ son nuevas y se utilizan para no tener que importar React en todas partes.

## Hooks

Los Hooks son una funcionalidad liberada con la versión 16.4 de React y su objetivo es facilitar las administración de estado a través de componentes funcionales.

Para revisar a fondo el concepto de Hooks, se va a usar como ejemplo un nuevo componente para realizar una búsqueda a través de los parámetros suministrados. La versión inicial del componente ~SearchParams~ sería:

#+begin_src js
// SearchParams.js
const SearchParams = () => {
  const location = "Seatle, WA";

  return (
    <div className="search-params">
      <form>
        <label htmlFor="location">
          Location
          <input id="location" value={location} placeholder="Location"/>
        </label>
      </form>
    </div>
  )
}
#+end_src

Para habilitar este componente en la aplicación es necesario hacer las actualizaciones de rutas pertinentes en el archivo ~App.jsx~:

#+begin_src js
// App.js
// comment Pet import, and add SearchParams
import SearchParams from "./SearchParams";

// in App.js, replace all the Pets
<SearchParams />;
#+end_src

Al revisar estos cambios en el navegador vía localhost, en el campo de entrada del componente de búsqueda se mostrará el texto "Seatle, WA". No obstante, al tratar de escribir sobre dicho campo, no se podrá hacer modificaciones. Esto es algo muy difícil de lograr, pero es un comportamiento natural en React. React detecta que un evento de escritura sucedió en el DOM, y por lo tanto algo debió cambiar, por consiguiente va a ejecutar una renderización. Es por esta razón que las funciones de renderizado son operaciones muy breves en React, ya que al encontrar diferencias el actualiza la cantidad mínima de cambios necesario en el DOM.

Por otra parte, observe que se esta usando ~className~ en lugar de ~class~ en el elemento HTML para las clases CSS. Esto se debe a que ~class~ es una palabra reservada en JS y JSX sigue siendo solo JS. Entonces, en su lugar, optaron por usar ~className~, que es el nombre de la API JS para interactuar con los nombres de las clases. Como ~className~, ~htmlFor~ se usa porque for es una palabra reservada en JS.

#+begin_src js
// SearchParams.js
import { useState } from 'react';

const SearchParams = () => {
  const [location, setLocaiton] = useState("Seatle, WA");

  function updateLocation(event) {
    setLocaiton(event.target.value);
  }

  return (
    <div className="search-params">
      <form>
        <label htmlFor="location">
          Location
          <input
            id="location"
            onChange={updateLocation}
            value={location}
            placeholder="Location
          />
        </label>
      </form>
    </div>
  )
}
#+end_src