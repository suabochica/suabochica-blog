#+TITLE: More React Hooks
#+DESCRIPTION: Serie que pretende explicar la funcionalidad de React Hooks
#+AUTHOR: Sergio Benítez
#+DATE:<2021-06-03 Thu>
#+STARTUP: fold
#+HUGO_BASE_DIR: ~/Development/suabochica-blog/
#+HUGO_SECTION: /post
#+HUGO_WEIGHT: auto
#+HUGO_AUTO_SET_LASTMOD: t

En esta publicación se va a profundizar en el uso de hooks más genércos suministrados por React. Dichos hooks son:

- ~useContext~
- ~useReducer~
- ~useCallback~
- ~useMemo~

La oferta de hooks puede llegar a ser abrumadora y es válido questionar ¿cuál es el propósito de los mismos?. Usar hooks es una forma de crear funcionalidades bajo una perspectiva declarativa. Ahora bien ¿hay alguna nueva funcionalidad en los react hooks? La respuesta es no. Básicamente los hooks son equivalentes a los componentes de clase de React en el sentido de que se pueden obtener los mismos resultados con estilos de programación diferentes. Otra pregunta frecuente es ¿react hooks llego para quedarse? y esta es una pregunta subjetiva ya que su respuesta dependerá de las intenciones y el contexto del equipo de desarrollo. Los que si es cierto es que los hooks cada vez tienen mayor aceptación dentro de la comunidad react, entonces es recomendable tener conocimientos previos sobre ellos. Por último ¿Están muertos los componentes de clase de react? las respuesta es no. Cómo la mayoría de las transiciones entre nuevas funcionalidades, hay unos nuevos patrones por asimilar pero esto no significa que se vayan a reemplazar. Por otra parte, los react hooks pueden coexistir con los componentes de clase, y por lo tanto los componentes de clase seguirán vigentes en los proyectos react. Siguiendo con esta línea tampoco es necesario actualizar los componentes de clase a react hooks ya que no hay nada malo con las clases de javascript y tampoco diferencias en rendimiento. De hecho la recomendación del equipo de desarrolladores de react es que no es necesario hacer una reescritura. Hooks simplemente es una alternativa a la creación de funcionalidades en react bajo un paradigma declarativo que hace que su implementación sea más sencilla y legible.

* Usos básicos de los hooks y sus reglas

Para el uso de hooks básicamente se tienen dos reglas:

1. Los react hooks solo pueden ser llamados por componentes funcionales de react.
2. Los react hooks se llaman en un nivel alto del componente funcional, y no pueden ser anidados dentro de funciones, condiciones o bucles.

La razón del porque los hooks no pueden anidarse se debe a que la biblioteca react siempre tiene presente los llamados a los mismos esperando el mismo orden cada vez que los evaluan durante la renderización del componente. Eso le permite a react preservar correctamente el estado de los hooks entre multiples llamados ~useState~ y ~useEffect~.

Para tener garantías sobre el cumplimiento de estas reglas hay un complemento designado para trabajar con ESLint, una herramienta de linter que permite identificar y reportar problemas en su código javascript. Dicho plugin es ~eslint-plugin-react-hooks~. Este complemento no atrapará todos los problemas pero sí la mayoría de ellos.

Para hacer uso de este linter, toca hacer las siguientes configuraciones: En el archivo ~package.json~ se debe instalar el plugin tal y como se muestra acontinuación:

#+begin_src json
  {
    "devDependencies": {
      "eslint": "^7.22.0",
      "eslint-plugin-react": "^7.23.1",
      "eslint-plugin-react-hooks": "^4.2.0",
      "prettier": "^2.2.1",
    }
  }
#+end_src

Luego, hay que crear un archivo ~eslintrc.json~ y pegar el siguiente contenido:

#+begin_src json
  {
    "parserOptions": {
      "ecmaVerison": 2020,
      "sourceType": "module",
      "ecmaFeatures": {
        "jsx": true
       },
    },
    "plugins": ["react-hooks"],
    "rules": {
      "react-hooks/rules-of-hooks": "error"
    }
  }
#+end_src

Con estas configuraciones el linter ya estará en condiciones de reportar los errores asociados a los incumplimientos de las reglas de los hooks. Si se obtiene un archivo ~index.js~ con el siguiente contenido:

#+begin_src js
  import React {useEffect, useState} from "react";

  const InputElement = () => {
    const random_bool = Math.random() >= 0.5;

    if (random_bool === true) {
      const [isLoading, setIsLoading] = useState(true);
    } else {
      const [isLoading, setIsLoading] = useState(false);
    }

    useEffect(() => {
      setTimeout(() => {
        setIsLoading(false)
      }, 2000)
    });

    return isLoading ? <div>Loading...</div> : <input placeholder="Enter some text">
  };

export default InputElement;
#+end_src

El linter reporta un error asociado a que los hooks no pueden definirse dentro de una condición. La versión apropiada de esta implementación es la siguiente:

#+begin_src js
  import React {useEffect, useState} from "react";

  const InputElement = () => {
    const random_bool = Math.random() >= 0.5;

    const [isLoading, setIsLoading] = useState(random_bool === true);

    useEffect(() => {
      setTimeout(() => {
        setIsLoading(false)
      }, 2000)
    });

    return isLoading ? <div>Loading...</div> : <input placeholder="Enter some text">
  };

export default InputElement;
#+end_src

* Aplicación react de conferencias

Para explicar los hooks mencionados en la introducción de esta publicación se va a tener como contexto una aplicación que suministra los contenidos de una conferencia. Dicha aplicación constará con dos páginas, un /home/ para especificar una descripción de la conferencia y una sección /speakers/ con la información relevante a los expositores de la conferencia.

Por otra parte, se reutilizará la validación de un campo de texto para suministrar un correo electrónico, y asó poder enviar un correo con las últimas actualizaciones de la conferencia. El siguiente repositorio almacena las diferentes versiones de la aplicación de conferencias contruida en react.

** TODO Add repo

Las siguientes imágenes corresponden a la interfaz gráfica de la aplicación y un diagrama que explica el modelo inicial de la distribución de componentes dentro de la aplicación.

** TODO Add UI image
** TODO Add diagram image

* ~useContext~
Con la liberación de la versión 16.8 de React el equipo de desarrollo incluyó un API de contexto cuyo propósito es habilitar el acceso a datos y funciones desde cualquier lugar de la aplicación de manera sencilla y directa. Antes de este API, para lograr dicho acceso a datos y funciones era necesario hacer un hack en JavaScript o pasar propiedades a través de los componentes de un lado a otro generando árboles de componentes complejos.

El API de contexto se desarrollo en vía contraria al patrón de diseño conocido como perforación de propiedades y los componentes de orden superior, ya que ambos enfoques motivan el uso de herencia de clases como una forma de pasar los datos entre componentes. El API de contexto es un hook que hace trivial el acceso a un contexto en cualquiera de los componentes funcionales sin actos antinaturales. Para ello, se crean etiquetas empaquetadoras en los eventos de renderización que literalmente no tienen nada que hacer cuando el UI se vuelve obsoleto.

Para desarolladores que han trabajado con mixins, el uso del hook ~useContext~ resulta familiar, ya que permite agregar información a una clase a través de un canal lateral.

Un caso de uso apropiado para el ~useContext~ es cuando la aplicación implica almacenar información de configuración, para así tenerla disponible en cualquier componente funcional de la misma.

En el ejemplo de la aplicación que recopila información de una conferencia, aún esta pendiente la asignación del día sábado o domingo para cada uno de los oradores. Este hecho es relevante para que los asistentes brinden una retroalimentación sobre sus interéses y puedan consolidar su cronograma.

A continuación se muestra como se expone un contexto en React:

#+begin_src js
// src/App.js
import React from "react";
import Home from "./Home";
import Speakers from "./Home";

export const ConfigContext = React.createContext();

const pageToShow = pageName => {
  if (pageName === "Home") return <Home/>;
  if (pageName === "Speakers") return <Speakers/>;
  return <div>Not Found</div>
}

const configValue = {
  showSignMeUp: true
  showSpeakersSpeakingDays: true
};

const App = ({ pageName }) => {
  return (
    <ConfigContext.Provider value={configValue}>
      <div>{pageToShow(pageName)</div>
    </ConfigContext.Provider>
  );
}
#+end_src

De este snippet, las siguientes líneas son las relevantes: la exportación de la variable ~ConfigContext~ que se asigna al método de ~React.createContext~. La variable ~configValue~ en donde se van a almacenar las configuraciones que se quieren compartir en el contexto. Para este caso puntual, ~showSignMeUp~ para mostrar o no el formulario de inicio de sesión, y el ~showSpeakersSpeakingDays~ para mostrar o no los filtros sobre el día de presentación de los oradores. Por último, actualizamos nuestro render haciendo el llamado a la etiqueta ~<ConfigContext.Provider>~ con el atributo ~value={configValue}~.

Para empezar se va a mostrar el consumo de la variable de configuración ~showSpeakersSpeakingDays~. Para ello es necesario realizar los siguientes cambios sobre el archivo ~Speakers.js~:

#+begin_src js
// src/Speakers.js
import React, { useContext, useEffect, useState } from "react";

import { Header } from "../src/Header";
import { Menu } from "../src/Menu";
import { ConfigContext } from "./App";
import SpeakerData from "./SpeakerData";
import SpeakerDetail from "./SpeakerDetail";

const Speakers = ({}) => {
  const [isLoading, setIsLoading] = useState(true);
  const [speakerList, setSpeakerList] = useState(true);
  const [speakingSaturday, setSpeakingSaturday] = useState(true);
  const [speakingSunday, setSpeakingSunday] = useState(true);
  const context = useContext(ConfigContext);

  useEffect(() => {/*...code to handle the filter over speakers and his day*/})

  // Handlers
  const handleChangeSaturday = () => { /*...*/ }
  const handleChangeSunday = () => { /*...*/ }
  const handleHeartFavorite = () => { /*...*/ }

  return (
    <div>
      <Header />
      <Menu />
      <div className="container">
        <div className="checkboxes">
          {context.showSpeakersSpeakingDays === false ? null : (
            <div className="day-checkbox">Saturday Speakers</div>
            <div className="day-checkbox">Sunday Speakers</div>
          )}
        </div>
        <div>{{/* JSX code to show the Speakers Card */}}</div>
      </div>
    </div>
  );
}
#+end_src

Las cosas importantes en este código son: el ~import~ del hook ~useContext~ desde ~react~. el ~import~ de la variable ~ConfigContext~ desde el archvio ~"./App"~ . La definición de la variable ~context~ asignada al hook ~useContext(ConfigContext)~. Notesé que en este llamado se pasa como parámetro la variable ~ConfigContext~. Por último, en el render el componente se agrega la condición ~context.showSpeakersSpeakingDays  === false~ sobre el JSX que renderiza los checkboxes para filtrar los días. En caso de que el valor de esta variable sea ~false~ se retorna ~null~ y por ende no se renderizan los checkboxes, de lo contrario si se muestran. Ya que el valor actual de la configuración ~showSpeakersSpeakingDays~ es ~true~ en el archivo ~./App.js~ los checkboxes son renderizados. Si se actualiza dicho valor a ~false~ se puede observar que los checkboxes no se muestran.

Ahora se va a seguir el mismo proceso pero esta vez la evaluación se va a realizar sobre el valor de la variable de configuracion ~showSignMeUp~. Para ello se actualiza el contenido del archivo ~SignMeUp.js~ de la siguiente manera: 

#+begin_src js
// src/SignMeUp.js

import React, { useState, useContext } from 'react';
import { ConfigContext } from './App';

const SignMeUp = ({ signupCallback }) => {
  const [email, setEmail] = useState('');
  const context = useContext(ConfigContext);

  return context.showSignMeUp === false ? null : (
    <div className="container">
      <div>
        <div className="content">
          <input
            placeholder="Enter Email"
            type="email"
            name="email"
            value={email}
            onChange={(e) => {
              setEmail(e.target.value);
            }}
          />
          &nbsp;
          <button
            disabled={!email.includes('@')}
            onClick={() => {
              signupCallback(email);
              setEmail('');
              alert('signup confirmed');
            }}
            className="btn"
            type="submit"
          >
            Get Updates
          </button>
        </div>
      </div>
    </div>
  );
};

export default SignMeUp;
#+end_src

Los pasos para consumir el valor de la variable ~context.showSignMeUp~ son los mismos que se indicaron para el caso de ~context.showSpeakersSpeakingDays~. Si el valor de esta variable es ~false~ no se va a renderizar el formulario para iniciar sesión. De lo contrario, si se va a mostrar el JSX correspondiente.
