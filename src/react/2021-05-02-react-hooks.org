#+TITLE: React Hooks
#+DESCRIPTION: Serie que pretende explicar la funcionalidad de Reack Hooks
#+AUTHOR: Sergio Benítez
#+DATE:<2021-05-02 Sun> 
#+STARTUP: fold
#+HUGO_BASE_DIR: ~/Development/suabochica-blog/
#+HUGO_SECTION: /post
#+HUGO_WEIGHT: auto
#+HUGO_AUTO_SET_LASTMOD: t

React Hooks representa un enorme paso hacia adelante hacia la construcción de aplicaciones plenamente funcionales con un uso mínimo de componentes de clase.

El manejo de estado y los eventos de ciclo de vida de un componente React requieren menos código y ganan legibilidad con el uso de los Hooks. Los Hooks respetan la forma en la que JavaScript fue diseñado para ser programado, y por ende se pueden implementar Hooks personalizados.

Los temas a revisar en esta serie son:

- React Hooks básicos incorporados
- React Hooks avanzados
- Comparación entre Hooks y componentes de clase

El propósito de estas publicaciones es lograr un entendimiento pleno de como usar los React Hooks para crear aplicaciones con solo componentes funcionales.

Para tener garantías del objetivo, es pre requisito tener conocimientos previos y sentirse cómo con las construcción de aplicaciones web con React. 

* ¿Qué son los React Hooks?

React Hooks agrega la habilidad de administrar el estado de React y la interfaz de usuario con los eventos del ciclo de vida de React en componentes funcionales, apoyándose en un estilo declarativo.

Quizas, el mayor aporte de React Hooks es la creación de componentes en una forma sencilla y de menor complejidad.

Básicamente los React Hooks son una vía para adjuntar lógica reutilizable en un componente existente. Antes de Hooks, la forma común de adjuntar lógica externa a un componente era usando las propiedades en la función ~render~ ó a través del patrón de componentes de orden superior. Lo íncomodo de este enfoque es que con frecuencia era necesario restructurar el código para atender una dependencia externa, haciendo engorroso y díficil de seguir el desarrollo.

La propuesta de React Hooks es una solución a este problema creando un mecanismo para extraer código que se pueda reutilizar entre componentes sin necesidad the introducir anidación en el árbol de componentes.

Siendo espécificos, los React Hooks son funciones JavaScript que le permiten al desarrollador usar el estado y los métodos del ciclo de vida dentro de los componentes React funcionales. En consecuencia, ahora se pueden construir aplicaciones React sin usar las clases de JavaScript. Ya no habrán más preocupaciones por lidiar con la palabra clave ~this~.

La siguiente tabla recopila el antes y el después del manejo de lógica retulizable en React:

| Antes de hooks                | Después de hooks                                                                 |
|-------------------------------+----------------------------------------------------------------------------------|
| Propiedades del render        | Adjunta lógica reutilizable en un componente existente                           |
| Componentes de orden superior | Usa el estado y los métodos de ciclos de vida dentro de un comoponente funcional |
| Código más complego           | Construye le 100% de la aplicación con componentes funcionales                   |

Los tres React Hooks más populares son:

- useState
- useRef
- useEffect

Tiempo de dar un vistazo mas profundo a cada uno de ellos:

* ~useState~

En los últimos años del mundo de la programación front-end, no importa el framework o la librería que se este utilizando, la siguiente declaración a sido una tendencia:

#+begin_quote
El estado ayuda a construir aplicaciones web de alto rendimiento
#+end_quote

La idea de estado consiste en que cada vez que se ve algo nuevo en la pantalla, sea rastreado como un estado nuevo. Para aterrizar este concepto se presenta el siguiente ejemplo:

#+CAPTION: Two way data-binding
  [[../images/react/react-hooks/01-two-way-data-binding.png]]

Esta  imagen ilustra los elementos relevantes para hacer un manejo de estado con la digitación de un correo electrónicio dentro de una etiqueta ~<Input/>~ que representa una caja de texto. Este elemento de entrada interactua con un modelo de datos en donde se va a almacenar lo que el usuairo esta escribiendo en el navegador. Cada caracter digitado actualizará el almacenamiento y posterior a dicha actualización en el modelo de datos la salida de este evento estará registrada en una etiqueta ~<Label>~. El almacenamiento de datos es conocido como /estado/.

A continuación se comparte una primera implementación del escenario descrito anteriormente. El plan es enganchar un campo de entrada de texto y cada vez que el valor cambie, como cuando un usuario escribe un carácter, se salvará el nuevo valor del campo de entrada como estado de React para posteriormente imprimir la salida de ese valor como una etiqueta debajo del campo de texto:

#+begin_src jsx
import React, { useState } from "react";

const InputElement = () => {
  const results = useState("");
  const inputText = results[0];
  const setInputText = results[1];

  return <input
    onChange={(event) => {}}
    placeholder="Enter some text"
  />
};

export default InputElement;
#+end_src

Al consultar este código en el navegador, se observa un campo de entrada de texto con su respectivo placeholder. Se recuerda que los campos de entrada de HTML soportan el evento ~onChange~ al cual se le puede asignar una función que será llamada cada vez que un usuario oprima una tecla. A dicha función se le pasa un evento como argumento y por ahora no va a retornar nada.

Tiempo de usar el primer hook. Se recuerda que los React Hooks son componibles lo que significa que se crean dentro del componente funcional tal y como se muestran en las primeras líneas del componente en el código anterior.

~useState~ es un React Hook que esta incluido dentro del paquete de la libreria React y es el que se usa para administrar estado en un componente funcional. Es por esta razón que se importa en la primera línea del snippet y al ser llamada se le pasa un valor inicial del estado sobre el cual se hará seguimiento. ~useState~ retornará un arreglo de dos valores con las versiones previas y actuales del estado. El primer valor, llamdo ~inputText~ es una referencia al estado mismo, que para este caso es el modelo de datos. El segundo valor del arreglo, con el nombre ~setInputText~ es una función que se llama para actualizar el modelo de datos.

Se puede usar destructuración sobre el ~useState~ para hacer más explícito el código, tal y como se muestra a continuación:

#+begin_src jsx
import React, { useState } from "react";

const InputElement = () => {
  const [ inputText, setInputText ] = useState("");

  return <input
    placeholder="Enter some text"
    onChange{(event) => {}}
  />
};

export default InputElement;
#+end_src

Esta es la forma típica de hacer uso del hook ~useState~. Retomando la funcionalidad del componente, por ahora se tiene que el campo de texto de entrada esta asociado al evento ~onChange~ para capturar el texto escrito por el usuario. La función ~setInputText~ al ser llamada actualiza el estado y dicho cambio se ve reflejado en la variable de lectura definida como ~inputText~. Es siguiente paso es muy predecible, ya que consiste en asociar estos tres elementos, llamand la función ~setInputText~ dentro del evento ~onChange~ que se le esta pasando al campo de texto, como señala el siguiente snippet:

#+begin_src jsx
import React, { useState } from "react";

const InputElement = () => {
  const [ inputText, setInputText ] = useState("");

  return <input
    placeholder="Enter some text"
    onChange{(event) => {setInputText(event.target.value)}}
  />
};

export default InputElement;
#+end_src

Para complementar la propuesta del diagrama de de enlace de datos bidireccional se debe imprimir el valor de la variable ~inputText~ actualizado, como se ilustra a continuación:

#+begin_src jsx
import React, { useState } from "react";

const InputElement = () => {
  const [ inputText, setInputText ] = useState("");

  return <div>
    <input
      placeholder="Enter some text"
      onChange{(event) => {setInputText(event.target.value)}}
    />
    <br/>
    {inputText}
  </div>
};

export default InputElement;
#+end_src

Ahora bien, para un mejor entendimiento de como fuciona el estado en React, se va a agregar un detalle en la implementación actual para imprimir el historial de la variable ~inputText~.

Para lograr este objetivo se sigue un esquema parecido al del evento ~onChange~ en el valor ~inputText~. Primero, se crea un nuevo estado que se inicializa con un arreglo vacío. Posteriormente, cada vez que se ejecute el evento ~onChange~ se va registrar dicha actualización en la variable ~historyList~. Para ello, se utiliza en _spread operator_ y se agrega al arreglo ~historyList~ el valor introducido por el usuario en el campo de texto. Por último se renderiza el valor del ~historyList~ en una lista con ayuda de la función ~.map~. El siguiente código conoslida la descripción previa:

#+begin_src jsx
import React, { useState } from "react";

const InputElement = () => {
  const [ inputText, setInputText ] = useState("");
  const [ historyList, setHistoryList ] = useState([]);

  return <div>
    <input
      placeholder="Enter some text"
      onChange{(event) => {
        setInputText(event.target.value)
        setHistoryList([...historyList, event.target.value])
      }}
    />
    <br/>
    {inputText}
    </hr><br/>
    {historyList.map(record => {
      return <li>record</li>
    })}
  </div>
};

export default InputElement;
#+end_src

Es importante aclarar una práctica sugerida con el uso del Hook ~useState~. Una alternativa a esta aproximación es el uso de un solo ~useState~ que se encargara de administrar el estado del ~inputText~ y el ~historyList~ a través de un objeto JavaScript. No obstante este enfoque complica la legibilidad del código y no ofrece ninguna ganancia. La recomendación del equipo React es usar multiple llamados a ~useState~

Con este ejemplo se obtiene un entendimiento sólido sobre como usar React Hooks en general, ya que todos los Hooks funcionan bajo las siguientes premisas:

- Solo están disponibles en componentes funcionales.
- Por convención usan el prefijo ~use~.
- Todos contribuyen a los eventos de ciclo de vida y la administración del estado en un componente React.
 
* ~useRef~
  
  - Note taken on [2021-05-14 Fri 18:18] \\
    note test
Una definición para el ~useRef~ hook es:

#+begin_quote
Mecanismo que se utiliza principalmente para permitir el acceso directo a un elemento en el DOM
#+end_quote

Es común usar los hooks ~useState~ y ~useRef~ para hacer cambios sobre lo que el usario esta viendo en la aplicación React. En casos muy esquivos bajo el contexto de React, es necesario implementar un acceso directo sobre un elemento HTML, aunque la recomendación sea evitarlo.

Para comprender el funcionamiento del ~useRef~ un escenario apropiado es un programa que cambie una imagen a blanco y negro por una imagen a color cuando se pase el cursor por encima de la imagen, y por supuesto la imagen vuelva a blanco y negro cuando el cursor ya no este por encima de la imagen. Este escenario sugiere un acceso directo sobre un elemento HTML: la imagen.

Para empezar, se va a crear el archivo ~/pages/ImageChangeOnMouseOver~, bajo el contexto de una aplicación estructurada con NextJS con el siguiente contenido:

#+begin_src jsx
import React from "react";

const ImageChangeOnMouseOver = () => {
  return (
    <div>
      <img src="/static/speakers/bw/speaker01.jsp" alt="" />
      &nbsp;
      &nbsp;
      <img src="/static/speakers/bw/speaker02.jsp" alt="" />
    </div>
  );
};

export default ImageChangeOnMouseOver;
#+end_src

Esta primera versión renderizará dos imágenes en el navegador a blanco y negro. Por ahora este contenido es estático y no hay acciones asociadas al evento de pasar el cursor sobre la imagen. Se resalta que las imágenes son contenidos estáticos y es una convención almacenarlas en la ruta ~public/static~ como se indica en el código anterior.

Para habilitar el efecto del hover sobre una imagen, se va a crear un componente con el nombre ~ImageToggleOnMouseOver~ al cual se delegará el uso de ~useRef~ y utilizará dos propiedades: ~primaryImg~ y ~secondaryImg~. Cada imagen atenderá el estado por defecto y el estado del hover respectivamente. En ese orden de ideas, esta sería la actualización sobre el archivo ~pages/ImageChangeOnMouseOver.js~

#+begin_src jsx
import React from "react";
import ImageToggleOnMouseOver from "../src/ImageToggleOnMouseOver";

const ImageChangeOnMouseOver = () => {
  return (
    <div>
      <ImageToggleOnMouseOver
        primaryImg="/static/speakers/bw/speaker-01.jpg"
        secondaryImg="/static/speakers/color/speaker-01.jpg"
        alt=""
      />
      &nbsp;
      &nbsp;
      <ImageToggleOnMouseOver
        primaryImg="/static/speakers/bw/speaker-02.jpg"
        secondaryImg="/static/speakers/color/speaker-02.jpg"
        alt=""
      />
    </div>
  );
};

export default ImageChangeOnMouseOver;
#+end_src

Bajo la estructura de carpetas de NextJS, la convención es incluir el nuevo compnente en la siguiente ruta: ~src/ImageToggleOnMouseOver.js~. La idea es inicial es hacer este componente funcional lo más simple posible y por ahora el primer objetivo es renderizar la imagen a blanco y negro. La primera versión del ~ImageToggleOnMouseOver~ tendría la siguiente contenido:

#+begin_src jsx
import React, { useRef } from "react";

const ImageToggleOnMouseOver = ({ primaryImg, secondaryImg }) => {
  return (
    <img
      src={primaryImg}
      alt=""
    />
  );
};

export default ImageChangeOnMouseOver;
#+end_src

Al revisar estos cambios en el navegador, el resultado visual es exactemente el mismo, dos imágenes en blanco y negro, con la diferencia de que ahora se esta utilizando un componente funcional de por medio.

Ahora es momento de manejar los eventos ~onMouseOver~ y ~onMouseOut~ sobre la imagen a través de los atributos de eventos. De esta manera, cuando determinado evento sea activado, se implementará la instrucción de cambiar el atributo ~src~ con la ruta de la imagen. Bajo este contexto el hook ~useRef~ entra en acción.

La forma en como ~useRef~ funciona es a través de la declaración de una constante, para este caso puntual ~imageRef~, la cual será asignada al atributo ~ref~. Con dicha asignación se habilita el acceso a la propiedad ~.current~ para obtener todos los atributos de la imagen, como por ejemplo el atributo ~src~ con la ruta de la imagen. Al tener acceso a este atributo, es posible sobreescribir el valor de la ruta de la imagen. El último paso es asociar la ruta con la imagen a color al evento ~onMouseOver~ y la ruta con la imagen a blanco y negro al evento ~onMouseOut~. A continuación se ilustra esta descripción en código:

#+begin_src jsx
import React, { useRef } from "react";

const ImageToggleOnMouseOver = ({ primaryImg, secondaryImg }) => {
  const imageRef = useRef(null);

  return (
    <img
      onMouseOver={() => {
        imageRef.current.src = secondaryImg;
      }}
      onMouseOut={() => {
        imageRef.current.src = primaryImg;
      }}
      src={primaryImg}
      alt=""
      ref={imageRef}
    />
  );
};

export default ImageChangeOnMouseOver;
#+end_src

Al abrir el navegador, se observa que las imágenes cambian de blanco y negro a color cuando el cursor del ratón se posiciona sobre alguna de ellas.

Esto es el hook ~useRef~ en pocas palabras. Un mecanismo para acceder a las propiedades de un elemento DOM y adicionar tareas especificas sobre dicho elemento.

Un característica llamativa de los hooks es que se pueden combinar, tal y como se explicará a continuación en un ejemplo que plantea un caso de uso para usar ~useRef~ en conjunto con ~useEffect~. El ejemplo también servirá para dar explorar el hook ~useEffect~.

* ~useEffect~ 
** TODO Similar to componentDidMount, componentDidUpdate and componentWillUnmount
** TODO Comparison table between class and functional components
** TODO Note about useLayoutEffect
** TODO Side effects definition
** TODO useEffect Syntax

#+begin_src jsx
import React, { useEffect } from "react";

const Syntax = () => {
  const [ checkBoxValue, setCheckBoxValue ] = useState(false);

  useEffect(() => {
    console.log('in useEffect');
    return () => {
      console.log('in useEffect clean up');
    }
  }, [checkBoxValue]);

  return (<div></div>);
};

export default Syntax;
#+end_src

** TODO Explain exercise
