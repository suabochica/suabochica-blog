#+TITLE: React Hooks
#+DESCRIPTION: Serie que pretende explicar la funcionalidad de Reack Hooks
#+AUTHOR: Sergio Benítez
#+DATE:<2021-05-02 Sun> 
#+STARTUP: fold
#+HUGO_BASE_DIR: ~/Development/suabochica-blog/
#+HUGO_SECTION: /post
#+HUGO_WEIGHT: auto
#+HUGO_AUTO_SET_LASTMOD: t

React Hooks representa un enorme paso hacia adelante hacia la construcción de aplicaciones plenamente funcionales con un uso mínimo de componentes de clase.

El manejo de estado y los eventos de ciclo de vida de un componente React requieren menos código y ganan legibilidad con el uso de los Hooks. Los Hooks respetan la forma en la que JavaScript fue diseñado para ser programado, y por ende se pueden implementar Hooks personalizados.

Los temas a revisar en esta serie son:

- React Hooks básicos incorporados
- React Hooks avanzados
- Comparación entre Hooks y componentes de clase

El propósito de estas publicaciones es lograr un entendimiento pleno de como usar los React Hooks para crear aplicaciones con solo componentes funcionales.

Para tener garantías del objetivo, es pre requisito tener conocimientos previos y sentirse cómo con las construcción de aplicaciones web con React. 

* ¿Qué son los React Hooks?

React Hooks agrega la habilidad de administrar el estado de React y la interfaz de usuario con los eventos del ciclo de vida de React en componentes funcionales, apoyándose en un estilo declarativo.

Quizas, el mayor aporte de React Hooks es la creación de componentes en una forma sencilla y de menor complejidad.

Básicamente los React Hooks son una vía para adjuntar lógica reutilizable en un componente existente. Antes de Hooks, la forma común de adjuntar lógica externa a un componente era usando las propiedades en la función ~render~ ó a través del patrón de componentes de orden superior. Lo íncomodo de este enfoque es que con frecuencia era necesario restructurar el código para atender una dependencia externa, haciendo engorroso y díficil de seguir el desarrollo.

La propuesta de React Hooks es una solución a este problema creando un mecanismo para extraer código que se pueda reutilizar entre componentes sin necesidad the introducir anidación en el árbol de componentes.

Siendo espécificos, los React Hooks son funciones JavaScript que le permiten al desarrollador usar el estado y los métodos del ciclo de vida dentro de los componentes React funcionales. En consecuencia, ahora se pueden construir aplicaciones React sin usar las clases de JavaScript. Ya no habrán más preocupaciones por lidiar con la palabra clave ~this~.

La siguiente tabla recopila el antes y el después del manejo de lógica retulizable en React:

| Antes de hooks                | Después de hooks                                                                 |
|-------------------------------+----------------------------------------------------------------------------------|
| Propiedades del render        | Adjunta lógica reutilizable en un componente existente                           |
| Componentes de orden superior | Usa el estado y los métodos de ciclos de vida dentro de un comoponente funcional |
| Código más complego           | Construye le 100% de la aplicación con componentes funcionales                   |

Los tres React Hooks más populares son:

- useState
- useRef
- useEffect

Tiempo de dar un vistazo mas profundo a cada uno de ellos:

* ~useState~

En los últimos años del mundo de la programación front-end, no importa el framework o la librería que se este utilizando, la siguiente declaración a sido una tendencia:

#+begin_quote
El estado ayuda a construir aplicaciones web de alto rendimiento
#+end_quote

La idea de estado consiste en que cada vez que se ve algo nuevo en la pantalla, sea rastreado como un estado nuevo. Para aterrizar este concepto se presenta el siguiente ejemplo:

#+CAPTION: Two way data-binding
  [[../images/react/react-hooks/01-two-way-data-binding.png]]

Esta  imagen ilustra los elementos relevantes para hacer un manejo de estado con la digitación de un correo electrónicio dentro de una etiqueta ~<Input/>~ que representa una caja de texto. Este elemento de entrada interactua con un modelo de datos en donde se va a almacenar lo que el usuairo esta escribiendo en el navegador. Cada caracter digitado actualizará el almacenamiento y posterior a dicha actualización en el modelo de datos la salida de este evento estará registrada en una etiqueta ~<Label>~. El almacenamiento de datos es conocido como /estado/.

A continuación se comparte una primera implementación del escenario descrito anteriormente. El plan es enganchar un campo de entrada de texto y cada vez que el valor cambie, como cuando un usuario escribe un carácter, se salvará el nuevo valor del campo de entrada como estado de React para posteriormente imprimir la salida de ese valor como una etiqueta debajo del campo de texto:

#+begin_src jsx
import React, { useState } from "react";

const InputElement = () => {
  const results = useState("");
  const inputText = results[0];
  const setInputText = results[1];

  return <input
    onChange={(event) => {}}
    placeholder="Enter some text"
  />
};

export default InputElement;
#+end_src

Al consultar este código en el navegador, se observa un campo de entrada de texto con su respectivo placeholder. Se recuerda que los campos de entrada de HTML soportan el evento ~onChange~ al cual se le puede asignar una función que será llamada cada vez que un usuario oprima una tecla. A dicha función se le pasa un evento como argumento y por ahora no va a retornar nada.

Tiempo de usar el primer hook. Se recuerda que los React Hooks son componibles lo que significa que se crean dentro del componente funcional tal y como se muestran en las primeras líneas del componente en el código anterior.

~useState~ es un React Hook que esta incluido dentro del paquete de la libreria React y es el que se usa para administrar estado en un componente funcional. Es por esta razón que se importa en la primera línea del snippet y al ser llamada se le pasa un valor inicial del estado sobre el cual se hará seguimiento. ~useState~ retornará un arreglo de dos valores con las versiones previas y actuales del estado. El primer valor, llamdo ~inputText~ es una referencia al estado mismo, que para este caso es el modelo de datos. El segundo valor del arreglo, con el nombre ~setInputText~ es una función que se llama para actualizar el modelo de datos.

Se puede usar destructuración sobre el ~useState~ para hacer más explícito el código, tal y como se muestra a continuación:

#+begin_src jsx
import React, { useState } from "react";

const InputElement = () => {
  const [ inputText, setInputText ] = useState("");

  return <input
    placeholder="Enter some text"
    onChange{(event) => {}}
  />
};

export default InputElement;
#+end_src

Esta es la forma típica de hacer uso del hook ~useState~. Retomando la funcionalidad del componente, por ahora se tiene que el campo de texto de entrada esta asociado al evento ~onChange~ para capturar el texto escrito por el usuario. La función ~setInputText~ al ser llamada actualiza el estado y dicho cambio se ve reflejado en la variable de lectura definida como ~inputText~. Es siguiente paso es muy predecible, ya que consiste en asociar estos tres elementos, llamand la función ~setInputText~ dentro del evento ~onChange~ que se le esta pasando al campo de texto, como señala el siguiente snippet:

#+begin_src jsx
import React, { useState } from "react";

const InputElement = () => {
  const [ inputText, setInputText ] = useState("");

  return <input
    placeholder="Enter some text"
    onChange{(event) => {setInputText(event.target.value)}}
  />
};

export default InputElement;
#+end_src

Para complementar la propuesta del diagrama de de enlace de datos bidireccional se debe imprimir el valor de la variable ~inputText~ actualizado, como se ilustra a continuación:

#+begin_src jsx
import React, { useState } from "react";

const InputElement = () => {
  const [ inputText, setInputText ] = useState("");

  return <div>
    <input
      placeholder="Enter some text"
      onChange{(event) => {setInputText(event.target.value)}}
    />
    <br/>
    {inputText}
  </div>
};

export default InputElement;
#+end_src

Ahora bien, para un mejor entendimiento de como fuciona el estado en React, se va a agregar un detalle en la implementación actual para imprimir el historial de la variable ~inputText~.

Para lograr este objetivo se sigue un esquema parecido al del evento ~onChange~ en el valor ~inputText~. Primero, se crea un nuevo estado que se inicializa con un arreglo vacío. Posteriormente, cada vez que se ejecute el evento ~onChange~ se va registrar dicha actualización en la variable ~historyList~. Para ello, se utiliza en _spread operator_ y se agrega al arreglo ~historyList~ el valor introducido por el usuario en el campo de texto. Por último se renderiza el valor del ~historyList~ en una lista con ayuda de la función ~.map~. El siguiente código conoslida la descripción previa:

#+begin_src jsx
import React, { useState } from "react";

const InputElement = () => {
  const [ inputText, setInputText ] = useState("");
  const [ historyList, setHistoryList ] = useState([]);

  return <div>
    <input
      placeholder="Enter some text"
      onChange{(event) => {
        setInputText(event.target.value)
        setHistoryList([...historyList, event.target.value])
      }}
    />
    <br/>
    {inputText}
    </hr><br/>
    {historyList.map(record => {
      return <li>record</li>
    })}
  </div>
};

export default InputElement;
#+end_src

Es importante aclarar una práctica sugerida con el uso del Hook ~useState~. Una alternativa a esta aproximación es el uso de un solo ~useState~ que se encargara de administrar el estado del ~inputText~ y el ~historyList~ a través de un objeto JavaScript. No obstante este enfoque complica la legibilidad del código y no ofrece ninguna ganancia. La recomendación del equipo React es usar multiple llamados a ~useState~

Con este ejemplo se obtiene un entendimiento sólido sobre como usar React Hooks en general, ya que todos los Hooks funcionan bajo las siguientes premisas:

- Solo están disponibles en componentes funcionales.
- Por convención usan el prefijo ~use~.
- Todos contribuyen a los eventos de ciclo de vida y la administración del estado en un componente React.
 
* ~useRef~
  
  - Note taken on [2021-05-14 Fri 18:18] \\
    note test
Una definición para el ~useRef~ hook es:

#+begin_quote
Mecanismo que se utiliza principalmente para permitir el acceso directo a un elemento en el DOM
#+end_quote

Es común usar los hooks ~useState~ y ~useRef~ para hacer cambios sobre lo que el usario esta viendo en la aplicación React. En casos muy esquivos bajo el contexto de React, es necesario implementar un acceso directo sobre un elemento HTML, aunque la recomendación sea evitarlo.

Para comprender el funcionamiento del ~useRef~ un escenario apropiado es un programa que cambie una imagen a blanco y negro por una imagen a color cuando se pase el cursor por encima de la imagen, y por supuesto la imagen vuelva a blanco y negro cuando el cursor ya no este por encima de la imagen. Este escenario sugiere un acceso directo sobre un elemento HTML: la imagen.

Para empezar, se va a crear el archivo ~/pages/ImageChangeOnMouseOver~, bajo el contexto de una aplicación estructurada con NextJS con el siguiente contenido:

#+begin_src jsx
import React from "react";

const ImageChangeOnMouseOver = () => {
  return (
    <div>
      <img src="/static/speakers/bw/speaker01.jsp" alt="" />
      &nbsp;
      &nbsp;
      <img src="/static/speakers/bw/speaker02.jsp" alt="" />
    </div>
  );
};

export default ImageChangeOnMouseOver;
#+end_src

Esta primera versión renderizará dos imágenes en el navegador a blanco y negro. Por ahora este contenido es estático y no hay acciones asociadas al evento de pasar el cursor sobre la imagen. Se resalta que las imágenes son contenidos estáticos y es una convención almacenarlas en la ruta ~public/static~ como se indica en el código anterior.

Para habilitar el efecto del hover sobre una imagen, se va a crear un componente con el nombre ~ImageToggleOnMouseOver~ al cual se delegará el uso de ~useRef~ y utilizará dos propiedades: ~primaryImg~ y ~secondaryImg~. Cada imagen atenderá el estado por defecto y el estado del hover respectivamente. En ese orden de ideas, esta sería la actualización sobre el archivo ~pages/ImageChangeOnMouseOver.js~

#+begin_src jsx
import React from "react";
import ImageToggleOnMouseOver from "../src/ImageToggleOnMouseOver";

const ImageChangeOnMouseOver = () => {
  return (
    <div>
      <ImageToggleOnMouseOver
        primaryImg="/static/speakers/bw/speaker-01.jpg"
        secondaryImg="/static/speakers/color/speaker-01.jpg"
        alt=""
      />
      &nbsp;
      &nbsp;
      <ImageToggleOnMouseOver
        primaryImg="/static/speakers/bw/speaker-02.jpg"
        secondaryImg="/static/speakers/color/speaker-02.jpg"
        alt=""
      />
    </div>
  );
};

export default ImageChangeOnMouseOver;
#+end_src

Bajo la estructura de carpetas de NextJS, la convención es incluir el nuevo compnente en la siguiente ruta: ~src/ImageToggleOnMouseOver.js~. La idea es inicial es hacer este componente funcional lo más simple posible y por ahora el primer objetivo es renderizar la imagen a blanco y negro. La primera versión del ~ImageToggleOnMouseOver~ tendría la siguiente contenido:

#+begin_src jsx
import React, { useRef } from "react";

const ImageToggleOnMouseOver = ({ primaryImg, secondaryImg }) => {
  return (
    <img
      src={primaryImg}
      alt=""
    />
  );
};

export default ImageChangeOnMouseOver;
#+end_src

Al revisar estos cambios en el navegador, el resultado visual es exactemente el mismo, dos imágenes en blanco y negro, con la diferencia de que ahora se esta utilizando un componente funcional de por medio.

Ahora es momento de manejar los eventos ~onMouseOver~ y ~onMouseOut~ sobre la imagen a través de los atributos de eventos. De esta manera, cuando determinado evento sea activado, se implementará la instrucción de cambiar el atributo ~src~ con la ruta de la imagen. Bajo este contexto el hook ~useRef~ entra en acción.

La forma en como ~useRef~ funciona es a través de la declaración de una constante, para este caso puntual ~imageRef~, la cual será asignada al atributo ~ref~. Con dicha asignación se habilita el acceso a la propiedad ~.current~ para obtener todos los atributos de la imagen, como por ejemplo el atributo ~src~ con la ruta de la imagen. Al tener acceso a este atributo, es posible sobreescribir el valor de la ruta de la imagen. El último paso es asociar la ruta con la imagen a color al evento ~onMouseOver~ y la ruta con la imagen a blanco y negro al evento ~onMouseOut~. A continuación se ilustra esta descripción en código:

#+begin_src jsx
import React, { useRef } from "react";

const ImageToggleOnMouseOver = ({ primaryImg, secondaryImg }) => {
  const imageRef = useRef(null);

  return (
    <img
      onMouseOver={() => {
        imageRef.current.src = secondaryImg;
      }}
      onMouseOut={() => {
        imageRef.current.src = primaryImg;
      }}
      src={primaryImg}
      alt=""
      ref={imageRef}
    />
  );
};

export default ImageChangeOnMouseOver;
#+end_src

Al abrir el navegador, se observa que las imágenes cambian de blanco y negro a color cuando el cursor del ratón se posiciona sobre alguna de ellas.

Esto es el hook ~useRef~ en pocas palabras. Un mecanismo para acceder a las propiedades de un elemento DOM y adicionar tareas especificas sobre dicho elemento.

Un característica llamativa de los hooks es que se pueden combinar, tal y como se explicará a continuación en un ejemplo que plantea un caso de uso para usar ~useRef~ en conjunto con ~useEffect~. El ejemplo también servirá para dar explorar el hook ~useEffect~.

* ~useEffect~ 

El uso del hook ~useEffect~ en componentes funcionales es similar a las funciones de ciclos de vida ~componentDidMount~, ~componentDidUpdate~ y ~componentWillUnmount~ en un componente de clase React.

Luego de que un componente es renderizado y el DOM esta listo para actualizaciones, bajo el contexto de un componente de clase la función ~componentDidMount~ es llamada. Para un componente funcional, la función que se pasa como primer argumento del ~useEffect~ es ejecutada.

Si el componente se actualiza, como por ejemplo un cambio en su estado, dentro del contexto de componentes de clase la función ~componentDidUpdate~ es llamada mientras que para un componente funcional la misma función ~useEffect~ es ejecutada con algunas condiciones espécificas que se revisarán más adelante.

Justo antes de que el componente se desmonte, en un componente de clase la función ~componentWillUnmount~ es llamada y para el caso de un componente funcional la función que se retorne en el primer argumento del ~useEffect~ será llamada.

Hay unas diferencias sútiles entre los métodos de un componente de clase y como funciona el ~useEffect~. Ambos son llamados después de que el componente sea renderizado, pero puede ser un poco complicado cuando se hacen referenecias a elementos del DOM de manera directa y también cuando se define un estado de forma asíncrona.

#+begin_quote
Incluso, hay otro hook popular llamado ~useLayoutEffect~ que resulta similar a las funciones ~componentDidMount~ y ~componentDidUnmount~ de un componente de clase. Su propósito es asegurar que el código escrito en un componente funcional funcione como se espera con componente funcionales.
#+end_quote

La siguiente tabla es un comparativo entre estos dos tipos de componentes bajo el contexto de React:

| Componente de clase React      | Componente funcional React                 |
|--------------------------------+--------------------------------------------|
| ~componentDidMount() {...}~    | ~useEffect(() => {...})~                   |
| ~componentDidUpdate() {...}~   | ~useEffect(() => {...})~                   |
| ~componentWillUnmount() {...}~ | ~useEffect(() => {... return () => {...})~ |

Otra forma de ver ~useEffect~ es la de un mecanismo para agregar _efectos secundarios_ a un componente funcional, hecho que antes de React Hooks no era posible.

La gente suele referirse a los efectos secundarios en componentes funcionales como algo contradictorio, ya que por lo general el propósito es que el componente funcional sea puro y libre de efectos secundarios. Es decir, que si el componente se llama con el mismo parametro una y otra vez, el mismo resultado se va a obtener sobre cada uno de estos llamados.

Por definición ~useEffect~ introduce efectos secundarios en el componente funcional, específicamente luego de que el componente ha sido renderizad, en los escenarios que se consolidaron en la última tabla.

En consecuencia, asociar los efectos secundarios como algo contradictorio es una premisa que se puede refutar. Por ejemplo, si se quieren agregar oyentes a los elementos DOM renderizados en un componente funcional, ~useEffect~ es la herramienta apropiada para abordar dicho escenario. Por su puesto cuando el componente desaparece, es responsabilidad del desarrollador remover los oyentes para evitar una fuga potencial de recursos en la aplicación web.

Se puede decir que esta descripción corresponde a un componente funcional puro, ya que así como se agregan oyentes, también se remueven de acuerdo al ciclo de vida del componente. No obstante, se resalta que una función pura garantiza el mismo resultado dado los parámentros de entrada, y el hecho de que se remuevan los oyentes no significa que siempre se vaya a obtener la misma salida.

Por último, se presenta la sintaxis de un componente funcional que utilizar ~useEffect~:

#+begin_src jsx
import React, { useEffect } from "react";

const Syntax = () => {
  const [ checkBoxValue, setCheckBoxValue ] = useState(false);

  useEffect(() => {
    console.log('in useEffect');
    return () => {
      console.log('in useEffect clean up');
    }
  }, [checkBoxValue]);

  return (<div></div>);
};

export default Syntax;
#+end_src

El primer parámetro debe ser una función. Para este ejemplo se tiene una función lambda que imprime el mensaje ~in useEffect~ en la consola y retorna otra función que como se explico anteriormente, será llamada cuando el componente se desmonte. Esta función imprimirá el mensaje ~in useEffect clean up~.

El segundo parámetro de ~useEffect~ es un arreglo con las dependencias del componente funcional. Si se ignora, entonces la función del primer parámetro sera ejecutada cuando el componente se renderize por primera vez y posteriormente en cada actualización subsecuente del componente. Si el arreglo es vacío, entonces la función asociada en el primer argumento del ~useEffect~ solo será llamada en el primer renderizado del componente.

Si se quiere que el componente sea renderizado basado en ciertas condiciones, los valores para cumplir dichas restricciones deben se parte de este arreglo. Para el ejemplo anterior, la condición aplicada es sobre la variable ~checkBoxValue~ que representa un booleano y hace parte del estado del componente. Esto significa que si el valor de ~checkBoxValue~ cambia, la función ~useEffect~ será llamada. 

* Usando ~useEffect~, ~useRef~ y ~useState~ para dar color con un efecto de scroll
