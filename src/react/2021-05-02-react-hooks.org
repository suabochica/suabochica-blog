#+TITLE: React Hooks
#+DESCRIPTION: Serie que pretende explicar la funcionalidad de Reack Hooks
#+AUTHOR: Sergio Benítez
#+DATE:<2021-05-02 Sun> 
#+STARTUP: fold
#+HUGO_BASE_DIR: ~/Development/suabochica-blog/
#+HUGO_SECTION: /post
#+HUGO_WEIGHT: auto
#+HUGO_AUTO_SET_LASTMOD: t

React Hooks representa un enorme paso hacia adelante hacia la construcción de aplicaciones plenamente funcionales con un uso mínimo de componentes de clase.

El manejo de estado y los eventos de ciclo de vida de un componente React requieren menos código y ganan legibilidad con el uso de los Hooks. Los Hooks respetan la forma en la que JavaScript fue diseñado para ser programado, y por ende se pueden implementar Hooks personalizados.

Los temas a revisar en esta serie son:

- React Hooks básicos incorporados
- React Hooks avanzados
- Comparación entre Hooks y componentes de clase

El propósito de estas publicaciones es lograr un entendimiento pleno de como usar los React Hooks para crear aplicaciones con solo componentes funcionales.

Para tener garantías del objetivo, es pre requisito tener conocimientos previos y sentirse cómo con las construcción de aplicaciones web con React. 

* ¿Qué son los React Hooks?

React Hooks agrega la habilidad de administrar el estado de React y la interfaz de usuario con los eventos del ciclo de vida de React en componentes funcionales, apoyándose en un estilo declarativo.

Quizas, el mayor aporte de React Hooks es la creación de componentes en una forma sencilla y de menor complejidad.

Básicamente los React Hooks son una vía para adjuntar lógica reutilizable en un componente existente. Antes de Hooks, la forma común de adjuntar lógica externa a un componente era usando las propiedades en la función ~render~ ó a través del patrón de componentes de orden superior. Lo íncomodo de este enfoque es que con frecuencia era necesario restructurar el código para atender una dependencia externa, haciendo engorroso y díficil de seguir el desarrollo.

La propuesta de React Hooks es una solución a este problema creando un mecanismo para extraer código que se pueda reutilizar entre componentes sin necesidad the introducir anidación en el árbol de componentes.

Siendo espécificos, los React Hooks son funciones JavaScript que le permiten al desarrollador usar el estado y los métodos del ciclo de vida dentro de los componentes React funcionales. En consecuencia, ahora se pueden construir aplicaciones React sin usar las clases de JavaScript. Ya no habrán más preocupaciones por lidiar con la palabra clave ~this~.

La siguiente tabla recopila el antes y el después del manejo de lógica retulizable en React:

| Antes de hooks                | Después de hooks                                                                 |
|-------------------------------+----------------------------------------------------------------------------------|
| Propiedades del render        | Adjunta lógica reutilizable en un componente existente                           |
| Componentes de orden superior | Usa el estado y los métodos de ciclos de vida dentro de un comoponente funcional |
| Código más complego           | Construye le 100% de la aplicación con componentes funcionales                   |

Los tres React Hooks más populares son:

- useState
- useRef
- useEffect

Tiempo de dar un vistazo mas profundo a cada uno de ellos:

* ~useState~

En los últimos años del mundo de la programación front-end, no importa el framework o la librería que se este utilizando, la siguiente declaración a sido una tendencia:

#+begin_quote
El estado ayuda a construir aplicaciones web de alto rendimiento
#+end_quote

La idea de estado consiste en que cada vez que se ve algo nuevo en la pantalla, sea rastreado como un estado nuevo. Para aterrizar este concepto se presenta el siguiente ejemplo:

#+CAPTION: Two way data-binding
  [[../images/react/react-hooks/01-two-way-data-binding.png]]

Esta  imagen ilustra los elementos relevantes para hacer un manejo de estado con la digitación de un correo electrónicio dentro de una etiqueta ~<Input/>~ que representa una caja de texto. Este elemento de entrada interactua con un modelo de datos en donde se va a almacenar lo que el usuairo esta escribiendo en el navegador. Cada caracter digitado actualizará el almacenamiento y posterior a dicha actualización en el modelo de datos la salida de este evento estará registrada en una etiqueta ~<Label>~. El almacenamiento de datos es conocido como /estado/.

A continuación se comparte una primera implementación del escenario descrito anteriormente. El plan es enganchar un campo de entrada de texto y cada vez que el valor cambie, como cuando un usuario escribe un carácter, se salvará el nuevo valor del campo de entrada como estado de React para posteriormente imprimir la salida de ese valor como una etiqueta debajo del campo de texto:

#+begin_src jsx
import React, { useState } from "react";

const InputElement = () => {
  const results = useState("");
  const inputText = results[0];
  const setInputText = results[1];

  return <input
    onChange={(event) => {}}
    placeholder="Enter some text"
  />
};

export default InputElement;
#+end_src

Al consultar este código en el navegador, se observa un campo de entrada de texto con su respectivo placeholder. Se recuerda que los campos de entrada de HTML soportan el evento ~onChange~ al cual se le puede asignar una función que será llamada cada vez que un usuario oprima una tecla. A dicha función se le pasa un evento como argumento y por ahora no va a retornar nada.

Tiempo de usar el primer hook. Se recuerda que los React Hooks son componibles lo que significa que se crean dentro del componente funcional tal y como se muestran en las primeras líneas del componente en el código anterior.

~useState~ es un React Hook que esta incluido dentro del paquete de la libreria React y es el que se usa para administrar estado en un componente funcional. Es por esta razón que se importa en la primera línea del snippet y al ser llamada se le pasa un valor inicial del estado sobre el cual se hará seguimiento. ~useState~ retornará un arreglo de dos valores con las versiones previas y actuales del estado. El primer valor, llamdo ~inputText~ es una referencia al estado mismo, que para este caso es el modelo de datos. El segundo valor del arreglo, con el nombre ~setInputText~ es una función que se llama para actualizar el modelo de datos.

Se puede usar destructuración sobre el ~useState~ para hacer más explícito el código, tal y como se muestra a continuación:

#+begin_src jsx
import React, { useState } from "react";

const InputElement = () => {
  const [ inputText, setInputText ] = useState("");

  return <input
    placeholder="Enter some text"
    onChange{(event) => {}}
  />
};

export default InputElement;
#+end_src

Esta es la forma típica de hacer uso del hook ~useState~. Retomando la funcionalidad del componente, por ahora se tiene que el campo de texto de entrada esta asociado al evento ~onChange~ para capturar el texto escrito por el usuario. La función ~setInputText~ al ser llamada actualiza el estado y dicho cambio se ve reflejado en la variable de lectura definida como ~inputText~. Es siguiente paso es muy predecible, ya que consiste en asociar estos tres elementos, llamand la función ~setInputText~ dentro del evento ~onChange~ que se le esta pasando al campo de texto, como señala el siguiente snippet:

#+begin_src jsx
import React, { useState } from "react";

const InputElement = () => {
  const [ inputText, setInputText ] = useState("");

  return <input
    placeholder="Enter some text"
    onChange{(event) => {setInputText(event.target.value)}}
  />
};

export default InputElement;
#+end_src

Para complementar la propuesta del diagrama de de enlace de datos bidireccional se debe imprimir el valor de la variable ~inputText~ actualizado, como se ilustra a continuación:

#+begin_src jsx
import React, { useState } from "react";

const InputElement = () => {
  const [ inputText, setInputText ] = useState("");

  return <div>
    <input
      placeholder="Enter some text"
      onChange{(event) => {setInputText(event.target.value)}}
    />
    <br/>
    {inputText}
  </div>
};

export default InputElement;
#+end_src

Ahora bien, para un mejor entendimiento de como fuciona el estado en React, se va a agregar un detalle en la implementación actual para imprimir el historial de la variable ~inputText~.

Para lograr este objetivo se sigue un esquema parecido al del evento ~onChange~ en el valor ~inputText~. Primero, se crea un nuevo estado que se inicializa con un arreglo vacío. Posteriormente, cada vez que se ejecute el evento ~onChange~ se va registrar dicha actualización en la variable ~historyList~. Para ello, se utiliza en _spread operator_ y se agrega al arreglo ~historyList~ el valor introducido por el usuario en el campo de texto. Por último se renderiza el valor del ~historyList~ en una lista con ayuda de la función ~.map~. El siguiente código conoslida la descripción previa:

#+begin_src jsx
import React, { useState } from "react";

const InputElement = () => {
  const [ inputText, setInputText ] = useState("");
  const [ historyList, setHistoryList ] = useState([]);

  return <div>
    <input
      placeholder="Enter some text"
      onChange{(event) => {
        setInputText(event.target.value)
        setHistoryList([...historyList, event.target.value])
      }}
    />
    <br/>
    {inputText}
    </hr><br/>
    {historyList.map(record => {
      return <li>record</li>
    })}
  </div>
};

export default InputElement;
#+end_src

Es importante aclarar una práctica sugerida con el uso del Hook ~useState~. Una alternativa a esta aproximación es el uso de un solo ~useState~ que se encargara de administrar el estado del ~inputText~ y el ~historyList~ a través de un objeto JavaScript. No obstante este enfoque complica la legibilidad del código y no ofrece ninguna ganancia. La recomendación del equipo React es usar multiple llamados a ~useState~

Con este ejemplo se obtiene un entendimiento sólido sobre como usar React Hooks en general, ya que todos los Hooks funcionan bajo las siguientes premisas:

- Solo están disponibles en componentes funcionales.
- Por convención usan el prefijo ~use~.
- Todos contribuyen a los eventos de ciclo de vida y la administración del estado en un componente React.
 
* ~useEffect~
