
#+TITLE: Rehidratando componentes React interactivos
#+DESCRIPTION: Serie para explicar el concepto de server rendering con React
#+AUTHOR: Sergio Benítez
#+DATE:<2021-08-16 Mon>
#+STARTUP: fold
#+HUGO_BASE_DIR: ~/Development/suabochica-blog/
#+HUGO_SECTION: /post
#+HUGO_WEIGHT: auto
#+HUGO_AUTO_SET_LASTMOD: t

Hasta ahora se ha logrado renderizar componentes React en el servidor pero sin interactividad alguna. Es evidente que para lograr esta funcionalidad es necesario el uso de una nueva herramienta. Por lo tanto es conveniente recalcar cuales son las limitaciones de los componentes renderizados en el servidor.

* Limitaciones de los componentes renderizados en el servidor

Es importante tener presente que los componentes renderizados en el servidor sin interactividad son una /fachada/. Una fachada es una construcción cuyo único propósito es proveer una impresión visual placentera, y puede enmascarar una estructura sólida y funcional ó una estructura que se está desmoronando. Los componentes renderizados en el servidor están realmente limitados si no usan rehidratación.

En otras palabras, los componentes renderizados en el servidor son solo pequeños pedazos HTML sin ninguna funcionalidad real. Al hacer clic en algún botón o interacción en un formulario, no se generan cambios en el estado. El uso de tooltips o organización de contenidos no va a funcionar y las comunicaciones automáticas con el servidor tampoco. Para evitar la figura de fachada, la tecnología a utilizar es la rehidratación.

* Entendiendo la rehidratación

Antes de agregar rehidratación en la aplicación, es conveniente revisar el concepto como tal. La siguiente definición es un punto de partida:

#+begin_notes
/Rehidratación/: Es el proceso para restaurar interactividad y funcionalidad en los componentes renderizados por el servidor.
#+end_notes

Para complementar esta definición, se recuerda que la librería de React que se ejecuta en el cliente tiene la capacidad de reconocer el entregable del servidor cuyo desarrollo inicial esta hecho en React. Por tanto, el código del cliente puede vincularse al marcado existente e instantáneamente puede sustituir el componente por una versión totalmente funcional sin necesidad de redibujar los elementos HTML.

La siguiente tabla compara las características de los componentes renderizados en el servidor que no son hidratados contra los que si son hidratados:

| Componentes No Hidratados                                                    | Componentes Hidratados                                                         |
|------------------------------------------------------------------------------+--------------------------------------------------------------------------------|
| Son extremadamente ligeros                                                   | Son ligeros pero requieren de librerías JavaScript                             |
| No se puede interacuar con ellos                                             | Son completamente interactivos                                                 |
| No precisan de JavaScript ni React para funcionar                            | Tanto React como JavaScript deben ser ejecutados en el dispositivo del cliente |
| No se actualizan por si mismo como respuesta a cambios en el modelo de datos | Ofrecen actualizaciones de alto rendimiento basado en el cambio de estado     |

Con estas aclaraciones, es tiempo de rehidratar el componente React que tenemos para la aplicación de encuestas.

* Agregando interactividad al componete renderizado en el servidor utilizando rehidratación
  
Estos son los detalles a tener en cuenta para agregar interactividad al componente renderizado en el servidor:

Primero se va a crear un servicio REST API que le permita acceder al cliente al mismo estado al que accede el servidor. Para ello se utiliza el Fetch API de JavaScript para realizar una petición GET que permita acceder al estado.

El segundo paso es rehidratar la aplicación en el cliente. El efecto se verá en los botones designados para las votaciones de las repuestas en la encuesta. Por ahora el resultado de la rehidratación no va a coincidir con el conjunto de datos, tan solo va reflejar una versión inicial.

#+begin_src javascript
// server/index.js
app.use(express.static("dist"));
app.get("/data", async (_request, response) => {
  response.json(data);
});
app.get("/", async (_request, response) => {
  const index = readFileSync("public/index.html", "utf8");
  const rendered = renderToString(<App {...data} />);
  response.send(index.replace("{{rendered}}", rendered));
});
#+end_src

#+begin_src javascript
// client/client.jsx
import React from 'react';
import ReactDOM from 'react-dom';

import { App } from './App';

let state = undefined;

// fetch("http://localhost:7777/data")
fetch("http://172.21.13.99:7777/data")
  .then(data => data.json())
  .then(json => {
    state = json;
    console.log("Got the state", state);
    render()
  });

function handleModifyAnswerVotes(answerId, increment) {
  state.answers = state.answers.map(answer => {
    if (answer.answerId !== answerId ) {
      return answer;
    } else {
      return { ...answer, upvotes: answer.upvotes + increment };
    }
  });
  render();
}

function render() {
  ReactDOM.hydrate(
    <App {...state} handleModifyAnswerVotes={handleModifyAnswerVotes}/>,
    document.querySelector("#container")
  );
}
#+end_src

#+begin_src javascript
// client/App.jsx
import React from 'react';

export const App = ({questions, answers, handleModifyAnswerVotes}) => (
  <div>
    <h1>Q&A Tool</h1>
    {questions.map(({questionId, content}) => (
      <div key={questionId}>
        <h3>{content}</h3>
        <div>
          {
            answers
              .filter(answer => answer.questionId === questionId)
              .map(({content, upvotes, answerId}) => (
                <div key={answerId}>
                  <span>{content} - {upvotes}</span>
                  <button onClick={() => handleModifyAnswerVotes(answerId, 1)}> + </button>
                  <button onClick={() => handleModifyAnswerVotes(answerId, -1)}> - </button>
                </div>
              ))
          }
        </div>
      </div>
    ))}
  </div>
);
#+end_src
