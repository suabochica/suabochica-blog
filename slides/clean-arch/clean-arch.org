#+REVEAL_ROOT: http://cdn.jsdelivr.net/reveal.js/3.0.0/
#+OPTIONS: toc:nil num:nil timestamp:nil
#+OPTIONS: reveal_width:1200 reveal_height:800 reveal_progress:t reveal_center:t
#+REVEAL_TRANS: zoom
#+REVEAL_THEME: night
#+REVEAL_INIT_OPTIONS: slideNumber:true
#+REVEAL_PLUGINS: (highlight)

#+TITLE: Clean Architecture in NodeJS
#+DESCRIPTION: Lifting is the "cheat mode" of tetris.
#+AUTHOR: Sergio Benítez
#+DATE: September 14, 2023


* Clean Architecture in NodeJS

** Working With Legacy Projects
:PROPERTIES:
:reveal_background: #4E1A3D
:END:

Learnings of software architecture and how a front end can do his initial steps in the backend world.

#+begin_notes

#+end_notes

** MVC Architecture

*** History of MVC Architecture

*** What are the three components behind the MVC pattern

*** The Model Component

*** The View Component

*** The Controller Component

*** MVC Demo

** The Clean Architecture

*** Fundamental blocks of the system

/image

#+begin_notes
1. Whatever type that makes it possible to run an *user interface*
2. The system *business logic/application core* which is used by the user interface to actually makes things happen
3. *Infrastructure* code, that connect our applicaton core to external tool
#+end_notes

*** Tools

#+begin_notes
It might feel weird to put a CLI console in the same "bucket" as a database engine, and although they have differente purposes, there are in fact tools used by the application.

The key difference is that, while the CLI console are used to *tell our application to do something*, the database enfin is *told by our application to do something*.
#+end_notes

***  Adapters

#+begin_notes
The code units that connect the tools to the application core are called adapters.

The adapters taht *tell* our application to do something are called /driving adapter/, while the ones that are *told* by our application to do something are called /driven adapters/.
#+end_notes

***  Ports

#+begin_notes
The adapters are no randomly created; they are created to fit a very specific entry point to the application core, a *port*.

A port *is nothing more than a specification* of how the tool can use or used by the application core.

It is important to note that the ports (*interfaces*) belong inside the business logic, while adapter belong outside.
#+end_notes

*** Driving Adapters

#+begin_notes
The driver adapters *wrap* around a port and use it to tell the application core what to do. *They translate whatever comes from a delivery mechanism into a method call in the app core*
#+end_notes

*** Driven Adapters

#+begin_notes
The driven adapters *implement* a port and are then injected into application core, wherever the port is required
#+end_notes

*** Inversion of control

#+begin_notes
A characteristic to note about this pattern is that the adapters depend on a specific tool and a specific port (by implementing an interface). But our business logic only depends on the port (interface), which is designed to fit the business logic needs, so it doesn’t depend on a specific adapter or tool.

i.e. the thirection of dependencies is towards the centre, it is the *inversion of control principle at the architectural level*
#+end_notes

** Takeaways

*** The map is not the territory

** Resources

- [[https://www.freecodecamp.org/news/mvc-architecture-what-is-a-model-view-controller-framework/][MVC Architecture]] by Jessica Wilkins
- [[https://mannhowie.com/clean-architecture-node?utm_source=pocket_saves][Clean Architecture NodeJS build a REST API]] by Howie Mann
- [[https://herbertograca.com/2017/11/16/explicit-architecture-01-ddd-hexagonal-onion-clean-cqrs-how-i-put-it-all-together/?source=post_page-----19cab9e93be7--------------------------------][DDD, Hexagonal, Onion, Clean, CQRS, ... How to put all together]], by Herberto Graca
